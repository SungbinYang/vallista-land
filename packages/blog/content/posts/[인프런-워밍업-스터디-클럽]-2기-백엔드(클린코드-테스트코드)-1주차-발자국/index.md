---
title: 인프런 워밍업 스터디 클럽 0기 백엔드(클린코드, 테스트코드) 1주차 발자국
tags:
  - 스터디
image: ./assets/01.jpg
date: 2024-09-26 10:05:27
series: 인프런 워밍업 스터디 클럽
draft: false
---

![banner](./assets/01.png)

> 이 블로그 글은 [박우빈님의 인프런 강의](https://inf.run/kHiWM)를 참조하여 작성한 글입니다.

드디어 0기때 이후 첫 발자국을 작성해보는 시간이다. 처음 마음 먹었던 초심을 생각하며 0기때보다 더 나은 활동을 해보자고 다짐하며 이 글을 써내려간다.

## 강의 소개

처음 이 강의를 듣기 전, 나는 아래와 같이 생각했다.

> 🤔 읽기 좋은 코드가 과연 무엇일까? 읽기 좋은 코드는 왜 필요할까?

해당 물음을 가지고 강의를 듣기 시작하였다.

우리는 코드를 작성(쓰기)보단 읽는데 시간을 더 많이 투자한다. 기존 코드에 내 코드를 추가하기 위해 내가 과거에 작성한 코드 혹은 다른 동료분들이 작성한 코드를 읽는다고 해보자. 하지만 이해가 안된다면 다시금 읽게 될 것이다. 그리고 많은 시간 끝에 이해라는 경지에 도달하거나 절망이라는 경지에 도달할 것이다.

![참고 이미지](./assets/reference.jpeg)

결국 코드를 작성한다는 것은 모두가 이해하기 쉬운 읽기 기반의 코드를 작성한다는 의미이다. 그리고 코드를 잘 짠다라고 말하는 것은 결국 읽기가 좋다는 의미이고 읽기 좋은 코드는 결국 미래를 위해 유지보수를 위해 필요한 작업이라고 생각이 든다.

또한 우린 가끔 이런 말을 하곤 한다. 나도 몇번 들었던 말이다.

> 코드는 작성하고 난 순간부터 레거시다.

여기서 레거시란, 오래되고 유지보수가 힘든 코드라고 생각하면 된다. 즉, 우리가 작성한 코드들은 먼 훗날의 레거시 코드가 되고 이 레거시 코드들을 유지보수 할 미래의 나 혹은 동료들을 위해 읽기 쉬운 코드를 작성함이 좋을듯 싶어진다. 나 또한 이번에 **제대로 학습**하여 실무에도 적용해볼 수 있는 기회가 되었으면 한다.

> ✅ 읽기 쉬운 코드 작성하는 현재까지 생각
>
> - 미래를 위해 그래야함
> - 유지보수 하기 좋음
> - 미래의 나와 동료를 위해 읽기 쉬운 **클린코드**를 작성해야함.

## 강의 구성

클린코드, 리팩토링 과정의 최고의 연습은 테스트코드를 작성하는 것이다.

테스트 코드를 작성문화를 가진 기업들은 일반적으로 아래의 절차를 가진다.

> 🛠 리팩토링 프로세스 (주관적인 생각)
>
> 1. 리팩토링 대상/범위 확인
> 2. 기능보장을 위한 테스트 코드 작성
> 3. 리팩토링
> 4. 테스트 코드 검증

위의 프로세스로 리팩토링을 진행하지만 우빈님께서는 현재 테스트코드 없이 진행한다고 하셨다. 또한 롬복도 사용을 하지 않으신다고 하며, 순수코드에 집중한다고 하셨다.

나 또한 이번에 우빈님 말씀대로 순수코드에 집중해보며, 시간과 여유가 있을 시, 내가 스스로 테스트 코드도 작성해봄이 좋을 것 같다!

## 강의에 사용할 용어들

> 📚 용어정리
>
> - 도메인(domain): 실무에 자주 사용되는 말들로, 해결하고자하는 문제영역들을 말한다.(비즈니스 요구사항 함축)
> - 도메인 지식: 도메인을 이해하고 해결하는데 필요한 지식
> - 레거시, 유산: 우리가 현자 가지고 있는 코드 \*
> - 조상: 과거의 나 / 동료 / 이 코드를 작성했던 개발자분들
> - 후손: 미래의 나 / 동료 / 내가 만든 코드들을 보게 될 많은 개발자분들

## 우리가 클린코드를 추구하는 이유

우리는 왜 클린코드라는 것을 지켜야 하는걸까? 결론부터 말하면 **가독성**때문이다. 가독성이 좋다라는 것은 이해가 잘된다는 것을 말하며 그것은 곧 유지보수가 수월해지며 그 만큼 우리의 시간과 자원을 절약한다.

세상에는 클린코드라 지칭하는 수많은 원칙들과 조언들이 존재한다. 하지만 이런 원칙들을 관통하는 아주 중요한 주제가 있는데 그게 바로 **추상**이다. 이번부터 추상을 한번 알아보자.

## 프로그램의 정의

그러면 추상이라는 것을 구체적으로 들어가기 전에 프로그램이 무엇인지 알아보자. 내가 생각하는 프로그램은 아래와 같다.

> 프로그램 = 설치하는 것

쉽게 생각해서 프로그램은 설치하는것이라 알고 있었다. 거기서 프로그램의 구조는 데이터 + 코드로 이루어진다 생각한다. 그래서 앞으로 이 2가지를 가지고 데이터의 추상과 코드의 논리를 가지고 학습해볼 예정이다.

## 추상과 구체

이제 본격적으로 추상을 들어가보자. **추상**하면 같이 따라 다니는 단어가 있는데 그것이 바로 **구체**이다. 이 두 단어는 매우 중요한 단어이다. 추상이라는 단어가 무엇일까? 우빈님께서 한자와 위키백과, 피카소의 명언을 참조하셔서 말씀을 해주셨듯이 추상은 아래와 같다.

> 📚 추상
>
> - 구체적인 정보에서 어떤 이미지를 뽑아내는 것이다
> - 중요한 정보는 가려내어 남기고 덜 중요한 정보는 생략하여 버린다.
> - **_추상은 항상 구체적인 실제에서 시작해야한다.(feat. 피카소)_**

즉, 위에 이야기를 토대로 나온 것이 추상화 레벨이다. 즉, 추상화라 하는 것은 내가 생각했을 때 추상적인 것이 몇 %이고 구체적인것이 몇 %이냐라는 것이다. 쉽게 비유하면 이런것이다. 친구와 이야기를 나눌때 진지함 30%이고 농담 70% 주제야!라고 한다. (개인적인 이야기)

아무튼 추상화는 중요한것 같다. 하지만 막상 너무 어렵게 느껴진다. 하지만 오히려 인간은 추상화 능력이 매우 뛰어난 존재이다. 예시를 보자.

친구와 아래와 같이 이야기를 했다 해보자.

> 🗒️ 예시
> Q. 주말에 뭐했어?
> A. 나는 하나의 큰 공간에서 나의 신경을 이용해 나의 걷는 수단으로 하나의 큰 구체를 차는 행위를 했어!

이렇게 했을 때 친구의 반응은 아래와 같을 수 있다.

![참고사진](./assets/reference01.png)

하지만 우리는 유추를 어느정도 해볼 수 있다.

> 🗒️ 예시
> Q. 주말에 뭐했어?
> A. 축구했어!

첫번째 예시는 구체이고 바로 위의 예시가 추상화 과정이다.

> 추상화: 정보 함축, 제거
> 구체화: 유추, 정보재현 이해

이것은 컴퓨터 과학에서도 사용된다.

> 🙋🏻 컴퓨터는 0과 1밖에 모르는데 어떻게 **고수준**의 작업을 할까?

먼저 정답을 이야기하면 바로 추상화과정때문이다. 그럼 자세히 들어가보자. 1bit가 무엇일까? 0과 1을 의미한다. 이것은 정보의 최소단위이고 이것은 결국 전구의 켜짐과 꺼짐을 나타내는데 이것을 존재성이라 한다. 1byte는 무엇일까? 용량의 최소단위이며 8bit를 묶어서 1byte라 한다. 또한 프로그래밍 언어에서 자료형을 이야기할때 몇byte를 묶어서 하나의 자료형을 나타낸다. 여기서 데이터(bit) 덩어리를 짤라서 묶고 어떻게 읽을것인가이다. 즉, 이것이 추상화이다.

또한 AND나 OR같은 논리 연산식도 데이터와 데이터가 만나 새로운 데이터를 만드는 방법을 의미한다.

즉, 종합해보면 이전에 프로그램을 데이터와 코드로 나타냈는데 위의 예시를 통해 각각 추상화가 가능하다는 것을 알 수 있다.

그러면 처음 질문으로 돌아가서 고수준 작업은 무엇일까? 고수준이라는 것은 추상화 레벨이 높다는 것이고 그와 반대로 저수준은 추상화 레벨이 낮다는 것이다. 대표적인 예시로 프로그래밍 언어와 기계어, 하드웨어와 운영체제와 어플리케이션, OSI7 Layer를 예로 보면 확 알 것이다.

그런데 우리는 읽기 좋은 코드를 이야기 하고 있는데 왜 추상화 과정이 필요할까? 적절한 추상화는 복잡한 데이터와 복잡한 로직을 단순화하여 이해하기 쉽도록 돕는다. 즉, 읽기 쉽다! 예시를 통해 보자.

성빈나라에 축구라는 것을 뻥뻥이라고 해보자. 그리고 친구한테 뻥뻥이했다라고 말하면 친구는 못알아 들을 것이다.

이렇게 못알아 듣는 이유 즉, 추상으로부터 구체를 유추하지 못한 이유는 추상화 과정에서 중요정보를 부각시키지 못했고 상대적으로 덜 중요한 정보를 제거했기 때문이다. 또한 해석자가 동일하게 공유하는 문맥이 아니기 때문이다. 이 말은 중요한 정보는 기준이 각각 다르고 즉, 도메인 별로 추상화 기준이 다르다는것을 알 수 있다. 그래서 다른 실무진들이 도메인 지식이 중요하다는 것도 이와 같기 때문이라 생각이 든다.

잘못된 추상화는 side-effect를 유발하며 이는 매우 critical하다. 적절한 추상화는 해당 도메인의 문맥 안에서 정말 중요한 핵심개념만 남겨서 표현한다. 적절한 추상화의 대표적인 행위가 바로 **이름짓기**인데 한번 이름짓기에 대해 살펴보자.

## 이름 짓기

개발자들이 업무를 하면서 무엇이 가장 힘드냐고 물어보면 10의 9은 "이름짓기"가 힘들다고 말한다. 나 또한 실무에서 변수명같은것을 짓는데만 30분을 소비한 경험이 있곤 하다.

그런데 진짜로 이름 잘 짓는게 중요할까? 나는 중요하다고 본다. 중요하지 않은 일을 이렇게 시간투자하면서 많은 개발자들이 힘들게 시간을 투자하고 있지 않을 것이다.

이름 짓는다는 행위는 **추상적인 사고**를 기반으로 한다.추상적인 사고는 첫째, 표현하고자 하는 구체에서 정말 중요한 핵심개념만을 추출하여 잘 드러내는 표현이며, 우리 도메인의 문맥안에서 이해되는 용어이다. 그럼 이름 짓는 주의 점들을 살펴보겠다.

### 단수, 복수 구분

끝에 -(e)를 붙여서 어떤 데이터(변수, 클래스)가 단수인지 복수인지 나타내는 것만으로도 읽는이에게 중요한 정보를 전달 할 수 있다.

### 이름 줄이지 않기

줄임말이라는 것은 가독성을 제물로 바쳐 효율성을 얻는 것으로 대부분 잃는 것에 비해 얻는 것이 적다. 즉, 자재하는 것이 좋으나 관용어처럼 많이 사람들이 사용하는 줄임말이 존재한다.

> column → col, latitude → lat, longitude → lon, count -> cnt

위의 예시에서 count를 줄이는 것은 우빈님은 비추하신다고 하셨다. 왜냐하면 겨우 5글자에서 3자로 줄이고 cnt만 봤을때 count라고 연상이 안된다고 하셨는데 그 이야기를 들어보니 나도 뭔가 와 닿지 않았다. 이전까지 실무에서도 귀찮을때 이렇게 줄이곤 했는데 조금 반성하게 되는 계기가 된 것 같았다.

또한 자주 사용하는 줄임말이 이해할 수 있는 것은 사실 문맥을 보고 알 수 있다. 예를 들어 익명 클래스에 저런 관용어가 있다고 해보자. 처음 보는 신입 개발자는 알 수 없을 것이다.

### 은어, 방언 사용 X

농담에서 파생된 용어, 일부 팀원, 현재 우리팀만 아는 은어 금지해야한다. 만약 다른 개발자가 해당 코드를 보면 이해하기 힘들기 때문이다. 또한 되도록 도메인 용어를 사용하자! 우리도 실무에서 도메인 용어 사전을 엑셀로 만들어서 사용하곤 한다. 이러닝 도메인을 가진 우리의 예로 보면 스코라는 단위를 표현할때 sco라는 표현 혹은 sc를 많이 사용한다. 물론 이렇게 정의되었더라도 하나로 정하면 그 프로젝트에서는 그것으로 밀고 사용해야한다.

### 좋은 코드 보고 습득하기

비슷한 상황에서 자주 사용하는 용어, 개념을 습득하자. github에 open되어 있는 라이브러리나 프레임워크의 코드를 보면서 용어들을 정리해 볼 필요가 있다고 느껴졌다.

> ex. pool, candidate, threshold등 (일상 용어 != 코드용어)

그럼 이제 코드를 통해 우빈님이 제공해준 코드를 고쳐보자.

자세한 것은 강의를 통해 확인해보고 간략히만 설명해보겠다.

아래와 같이 의미가 없는 변수들을 변경해보았다. 대표적으로 for문의 i와 j의 변수를 아래와 같이 변경해보았다.

```java
for (int row = 0; row < 8; row++) {
  for (int col = 0; col < 10; col++) {
    board[row][col] = "□";
  }
}
```

이런식으로 나머지도 수정을 해보았다. 추가적으로 나는 주석도 달아보았다. 주석이 없으니 우빈님과 코드를 읽으면서 뭔가 난해한 부분도 많기 때문에 주요 로직에 주석을 다는것도 Readable code이지 않을까?

## 메서드와 추상화

잘 쓰여진 코드의 메서드는 반드시 1개의 주제를 가져야 한다. 메서드의 선언부로 우리는 구체적인 내용을 추상화 할 수 있다. 만약 그렇게 하기 힘들다면 그 메서드는 2가지 이상의 일을 하고 있다고 볼 수 있다. 역할분리가 힘든 메서드라고 나는 생각한다.

그래서 메서드를 작성할때 생략할 정보와 의미를 부여하고 드러낼 정보를 구분하는것이 중요하다. 즉, **추상화**가 중요하다. 만약 아까처럼 메서드 내용을 보고 이름을 유추하기 힘들다면 그 메서드 안에 의미를 담을 수 있는 더 작은 단위로 쪼개고 그 쪼갠것을 보고 하나의 유추할 수 있는 포괄적 의미의 메서드 이름을 적어보는 것이 좋을 것 같다.

## 메서드 선언부

메서드 선언부는 아래와 같이 구성되어 있다.

```java
반환타입 메서드명(파라미터) {}
```

> ✅ 용어정리
>
> 메서드 명과 파라미터를 통틀어서 메서드 시그니처라는 용어를 사용한다.
> 메서드 시그니처를 통해서 자바에서 오버로딩이 가능하다.

메서드는 추상화된 구체를 유추할 수 있는 적절한 의미가 담긴 이름이어야 한다. 또한 메서드의 파라미터라는 정보를 통하여 더 풍부한 의미를 전달할 수 있다. 보통 메서드 명을 동사로 시작하는 경우가 있지만 **반드시 일 필요는 없다.** 단순 데이터 반환 같은 경우는 명사로 하여도 무방하다.

> 파라미터와 같이 사용할때 메서드 명은 보통 전치사로 끝나는게 좋다고 하셨다.

```java
int selectedColIndex = convertColFrom(cellInputCol);
int selectedRowIndex = convertRowFrom(cellInputRow);
```

위와 같이 표기하면 확실히 읽을때 명확해짐을 볼 수 있었다.

파라미터의 타입, 개수, 순서를 통하여 의미전달이 또한 가능하다. 아래의 코드를 살펴보자.

```java
public void createLecture(String title, String localDateToString) {}

public void createLecture(String lectureTitle, LocalDate openDate) {}
```

위의 두 메서드중에 2번째것이 명확하다는 것을 알 수 있을것이다. 첫번째 메서드는 메서드를 사용할때 두번째 파라미터에 무엇을 넣어야 하는지 불분명하기 때문이다.

여기서 파라미터는 외부와 소통하는 창이라고 볼 수 있다. 사용하는 입장에서 어떤 정보가 필요한지 알려주는 기능을 한다.

또한 메서드 시그니처에 납득이 가는 적절한 타입의 반환값을 돌려줘야 한다. 만약 납득이 안 간다면 문제가 있는 메서드일 확률이 높다. 또한 `void` 대신 충분히 반환할만한 가치가 있는 값이 있는지 고민을 해보는게 좋을 것이다.

그리고 추가적으로 메서드를 리팩토링 과정을 거쳐 추상화함에 있어서 너무 긴 코드들을 메서드로 묶는다는 생각보단, 추상화가 필요한 부분을 리팩토링한다고 생각하는것이 좋다. 단 1줄이더라도 추상화할만한 가치가 있다면 하는것이 좋다.

그래서 강의를 통해 예제 프로젝트를 기능단위로 묶어서 메서드로 분리함으로 조금 더 깔끔한 코드로 리팩토링 실습을 해보았다.

## 추상화 레벨

우리는 이전까지 엄청 긴 코드들(구체)에서 추상화 과정을 거쳐서 메서드를 추출해보았다. 이렇게 메서드를 추출하는 그 순간 읽는 자 기준으로 외부세계와 내부세계의 경계가 생긴다. 당연하게 생각해보면 쭉 코드를 읽다가 갑자기 메서드를 보면 살짝 멈칫할 것이다. 여기서 외부세계란 추상화 레벨이 높은 세계이고 내부세계란 추상화 레벨이 낮은 구체라고 생각하면 좋을 것이다. 그래서 내부세계에서는 구체적인 내용이 들어가 있고 외부세계에서는 메서드의 필요한 파라미터를 내부세계로 넘겨서 메서드명과 반환타입을 전달하게 될 것이다.

또한 **하나의 세계 안 에서 추상화 레벨은 동등해야 한다.** 만약 그렇지 못한다면 레벨을 맞추게 추상화 과정을 거쳐야 한다.

그래서 실습을 통하여 같은 추상화 레벨이 되도록 메서드들을 분리해보았는데 나는 여기서 몇몇 이해가 안되는 부분이 있었다. 이 부분은 질문을 해봐야 겠다.

## 매직 넘버, 매직 스트링

매직 넘버, 매직 스트링을 알기 전에 상수부터 알아보자. 상수로 추출한다는 것은 하나의 이름을 부여한다는 것이고 즉, 추상화 한다는 것이다.

매직 넘버와 매직 스트링은 의미를 갖고 있으나 상수로 추출되지 않은 숫자나 문자열을 의미하며 이름을 부여함으로 읽기 좋은 코드에 다가간다.

실습을 통해 매직 넘버와 매직 스트링을 상수로 추출해보았다.

## 미션1

### 예시 1

- 추상: 동호회 사람들과 모여서 축구를 한다.
- 구체
  - 같은 좋아하는 것을 목표로 모인 연합의 사람들과 모인다.
  - 경기를 하기 위해 랜덤으로 팀을 나눈다.
  - 서로 다른 지점에 하나의 구체를 넣기 위해 사람의 신경계와 근육을 이용하여 승부를 한다.

### 예시 2

- 추상: 크롬 웹 브라우저에 www.google.com을 입력하여 구글 홈페이지를 접속한다.
- 구체:
  - 사용자가 크롬에 www.google.com을 입력하면, 브라우저는 먼저 DNS 캐시, hosts 파일 등을 확인한 후, 도메인의 IP 주소를 찾기 위해 DNS 서버에 요청을 보낸다.
  - IP 주소를 얻으면, 브라우저는 TCP 3-way 핸드셰이크로 서버와 연결을 설정하고, HTTPS의 경우 TLS 핸드셰이크를 통해 보안 통신을 설정한다.
  - 이후 HTTP 요청을 서버로 전송하고, 서버는 HTML 데이터를 응답하여 브라우저가 이를 렌더링해 화면에 표시
  - 로컬 네트워크에서는 ARP를 사용해 IP 주소를 MAC 주소로 변환하여 데이터가 전송

### 예시 3

- 추상: 어느 웹 사이트에 로그인을 진행한다.
- 구체
  - 로그인 정보 입력:
    사용자가 웹사이트의 로그인 페이지에 사용자 이름과 비밀번호를 입력하고 "로그인" 버튼을 누릅니다.
  - HTTPS 요청 전송:
    브라우저는 이 로그인 정보를 HTTPS 프로토콜을 사용해 암호화하여 서버로 전송합니다. HTTPS는 TLS를 통해 데이터를 보호하여 중간에서 탈취되지 않도록 보장합니다.
  - 서버에서 인증 처리:
    서버는 받은 로그인 정보를 데이터베이스의 사용자 정보와 비교합니다. 입력된 비밀번호는 보통 해시(Hash) 값으로 변환되어 비교되며, 만약 일치한다면 인증이 성공합니다.
  - 세션 또는 토큰 생성:
    인증이 성공하면 서버는 사용자에게 세션 ID나 JWT(JSON Web Token)와 같은 토큰을 발급합니다. 이 세션이나 토큰은 사용자가 인증된 상태임을 나타내며, 클라이언트에 저장됩니다(세션 쿠키 또는 로컬 스토리지).
  - 인증 상태 유지:
    이후 사용자가 웹사이트의 다른 페이지를 요청할 때, 브라우저는 이 세션 ID나 토큰을 함께 전송하여 사용자가 인증된 상태로 남아 있을 수 있도록 합니다.

> 📚 추가 참조
>
> https://johnlock.tistory.com/405
>
> https://maily.so/trendaword/posts/52a9a219
