---
title: 인프런 워밍업 스터디 클럽 2기 백엔드(클린코드, 테스트코드) 3주차 발자국
tags:
  - 스터디
image: ./assets/01.png
date: 2024-10-09 08:32:27
series: 인프런 워밍업 스터디 클럽 2기
draft: false
---

![banner](./assets/01.png)

> 이 블로그 글은 [박우빈님의 인프런 강의](https://inf.run/kHiWM)를 참조하여 작성한 글입니다.

어느덧 벌써 워밍업 클럽이 막바지로 가고 있는 것 같다. 워밍업 클럽을 참여 전의 나보다 많이 성장했는가를 항상 발자국 쓸때 돌이켜 물어보는 것 같다. 과연 성장을 했을끼? 나는 당당히 성장을 하였다고 생각을 한다. 해당 스터디를 통해 나의 생활도 지식도 성장이 되었다 생각하며 해당에 대한 물음은 워밍업 클럽 수료 후에 다시 되물음을 해보겠다.

이번 주차에서는 이제 Readable Code 강좌가 완강이 되고 Practical Testing 강좌를 시작하는 주차다. 이번주도 열심히 달려본 내역들을 작성해보겠다.

## 강의소개

이 강좌는 테스트가 처음이거나 테스트 코드는 들어봤거나 작성하려고 시도를 해본 경험이 있는등 테스트가 궁금한 모든 분들을 위해 나온 강의이다. 나도 해당 테스트를 어떻게 하면 잘 작성할지가 궁금하여 이 강좌를 듣게 되고 해당 워밍업 클럽을 참여하게 된 이유이기도 하다.

테스트를 작성하는 역량은 채용시장에서 주니어 개발자에게 기대하는 요소 중 하나다. 채용시 구현과제 등에서 테스트 작성여부, 테스트 코드 구현방식을 확인한다. 또한 소프트웨어의 품질을 보장하는 방법으로 그 중요성을 알고 있는지도 확인을 하기도 한다고 한다.

이번 강좌에서는 다음과 같은 목표를 두고 학습을 진행한다고 한다.

> 📚 목표
>
> 1. 테스트 코드가 필요한 이유
> 2. 좋은 테스트 코드란 무엇일까?
> 3. 실제 실무에서 진행하는 방식 그대로 테스트를 작성해가면서 API를 설계하고 개발하는 방법
> 4. 정답은 없지만 오답은 존재한다. 구체적인 이유에 근거한 상세한 테스트 작성 팁

벌써부터 많은 기대를 품으며 다음 강의로 바로 가봐야 겠다.

## 어떻게 학습하면 좋을까?

효과적인 학습을 하기 위해 가장 먼저 선행되어야 하는 것은 바로 **무엇을 모르는지 아는 것**이다. 무엇을 모르는 지 아는것은 찾아볼 수 있게 된다는 것이다.

우리는 학습을 하면서 이 부분은 완벽히 아는 부분, 이 부분은 반만 아는 부분, 이 부분은 처음 들어보는 부분으로 구분된다. 그래서 강좌에서 함계 학습한 키워드와 추가 학습을 위한 키워드를 분리하여 키워드 기반으로 정리를 해주신다고 하니 많은 기대를 가지며 다음 강의부터 본격적으로 달려 볼 예정이다.

## 테스트는 왜 필요할까?

기술 학습에 있어서 '왜?'가 중요하다. 테스트하면 생각나는게 무엇일까? 나는 처음 테스트코드를 볼때 **굳이 해야하나?** **개발시간만 더 늘릴뿐일텐데라는 생각을 하였다.**

그런데 만약 테스트코드가 없이 실제 인간이 수동으로 테스트를 하면 매우 큰 문제들을 야기할 수 있다. 인간은 실수의 동물이기 때문이다. 또한 만약 기능을 개발할때 기존 기능을 건들게 된다면 기존 기능도 다시 테스트를 하는 시간낭비가 발생한다.

> ✅ 테스트 작성을 안하면?
>
> 1. 커버할 수 없는 영역 발생
> 2. 경험과 감에 의존
> 3. 늦은 피드백
> 4. 유지보수 어려움
> 5. 소프트웨어에 대한 신뢰가 떨어딘다.

### 테스트 코드를 작성하지 않으면?

- 변화가 생기는 매 순간마다 발생할 수 있는 모든 case를 고려해야한다.
- 변화가 생기는 매 순간마다 모든 팀원이 동일한 고민을 해야한다.
- 빠르게 변화하는 소프트웨어의 안정성을 보장할 수 없다.

### 테스트코드가 병목이 된다면?

- 프로덕션 코드의 안정성을 제공하기 힘들어진다.
- 테스트 코드 자체가 유지보수하기 어려운 새로운 짐이 된다.
- 잘못된 검증이 이루어질 가능성이 생긴다.

### 올바른 테스트 코드

- 자동화 테스트로 비교적 빠른 시간 안에 버그를 발견할 수 있고 수동 테스트에 드는 비용을 크게 절약할 수 있다.
- 소프트웨어의 빠른 변화를 지원한다.
- 팀원들의 집단 지성을 팀 차원의 이익으로 승격시킨다.
- 가까이 보면 느리지만 멀리보면 빠르다.

## 샘플 프로젝트 소개 & 개발 환경 안내

해당 테스트 섹션에서는 카페 키오스크 시스템을 만들면서 테스트 학습을 할 예정이다.

> 🛠 개발환경
>
> - IntelliJ Ultimate
> - Vim(Plugin)

## 프로젝트 세팅

인텔리제이를 활용하여 스프링부트 프로젝트를 생성하고 build.gradle의 의존성 정리를 하였다.

## 수동테스트 VS. 자동화된 테스트

### 요구사항

- 주문목록에 음료 추가/삭제 기능
- 주문목록에 전체 지우기
- 주문목록 총 금액 계산하기
- 주문 생성하기

해당 부분을 토대로 콘솔기반 비즈니스 로직을 작성하였고 테스트 강의이니 해당 로직을 테스트 하기 위해 이 중 음료 추가에 대한 로직을 아래와 같이 작성했다.

```java
@Test
void add() {
    CafeKiosk cafeKiosk = new CafeKiosk();
    cafeKiosk.add(new Americano());

    System.out.println(">>> 담긴 음료 수: " + cafeKiosk.getBeverages().size());
    System.out.println(">>> 담긴 음료: " + cafeKiosk.getBeverages().get(0).getName());
}
```

위의 코드를 봤을 때 이렇게 테스트코드를 짜면 안된다고 직감을 했을 것이다. 왜냐하면 일단 최종단계에서 사람이 개입하고 어떤게 맞고 어떤게 틀리는지 모른다는 것이다. 또한 이 테스트는 100% 성공하는 케이스이기 때문에 뭔가 테스트라고 하기에 모호한것 같다.

## JUnit5로 테스트하기

### 단위테스트

- **작은** 코드 단위를 **독립적**으로 검증하는 테스트
- 검증속도가 빠르고 안정적이다.

### Junit5

- 단위 테스트를 위한 테스트 프레임워크

### AssertJ

- 테스트 코드 작성을 원활하게 돕는 테스트 라이브러리
- 풍부한 API, 메서드 체이닝 지원

해당 지식을 기반으로 우리가 이전 시간에 작성한 아메리카노부분과 카페머신의 대한 단위 테스트를 AssertJ를 이용하여 작성해보는 시간을 가졌다.

## 테스트 케이스 세분화하기

스스로에게 질문해보자. 암묵적이거나 아직 드러나지 않은 요구사항이 있는지를 확인해보자. 그리고 해피케이스와 예외케이스를 둘다 생각하며 항상 경계값 테스트를 해보자.

> 경계 값은 범위(이상, 이하, 초과, 미만), 구간, 날짜등을 일컫는다.

그래서 우리는 음료에 여러잔을 담는 기능을 개발하고 해당 부분의 해피케이스에 관한 테스트를 작성했다. 또한 예외 케이스를 생각해 로직을 작성하고 해당 예외케이스에 대한 로직을 작성하게 되었다.

## 테스트하기 어려운 영역을 분리하기

테스트하기 어려운 영역은 다음과 같다.

- 관측할 때마다 다른 값에 의존하는 코드
  - 현재 날짜/시간, 랜덤 값, 전역변수/함수, 사용자 입력 등
- 와부세계에 영향을 주는 코드
  - 표준출력, 메세지 발송, 데이터베이스 기록

그래서 우리는 실습으로 주문을 생성할때 가게 영업시간이 아닐시, 주문을 못하게 하는 상황의 로직을 작성했고 테스트코드 작성 시 문제가 생겼다. 내가 현재 새벽에 테스트코드를 돌렸고 영업시간 전이기에 테스트코드가 실패한것이다. 결국 이 부분은 날짜를 파라미터로 받게 변경하여 해결하였다.

> 📚 순수함수
>
> - 같은 입력에는 같은 결과
> - 외부세상과 단절된 형태
> - 테스트하기 쉬운 코드

## TDD: Test Driven Development

- 프로덕션 코드보다 테스트 코드를 먼저 작성하여 테스트가 구현과정을 주도하도록 하는 방법론
- Red: 실패하는 테스트 작성
- Green: 테스트 통과하기 위한 최소한의 코딩
- Refactor: 구현코드 개서느 테스트 통과 유지

### 피드백

TDD는 빠르게 피드백을 자동으로 받을 수 있다.

### 선 기능 후 테스트 작성

- 테스트 자체의 누락 가능성
- 특정 테스트 케이스(해피 케이스)만 검증할 가능성이 크다.
- 잘못된 구현을 다소 늦게 발견할 가능성이 있다.

### 선 테스트 후 기능 작성

- 복잡도가 낮은 테스트 가능한 코드로 구현할 수 있게 된다.
  - 유연하며 유지보수가 쉬운
- 쉽게 발견하기 어려운 엣지 케이스를 놓치지 않게 해준다.
- 구현에 대한 빠른 피드백 가능
- 과감한 리팩토링이 가능

> 클라이언트 관점에서의 피드백을 주는 Test Driven

## 테스트는 []다.

테스트는 무엇일까? 테스트는 문서라고 볼 수 있다.

- 프로덕션 기능을 설명하는 테스트 코드 문서
- 다양한 테스트 케이스를 통해 프로덕션 코드를 이해하는 시각과 관점을 보완
- 어느 한 사람이 과거에 경험했던 고민의 결과물을 팀 차원으로 승격시켜서 모두의 자산으로 공유할 수 있다.

## DisplayName을 섬세하게

`@DisplayName`을 사용하여 테스트 명을 구체화할때 명사의 나열보단 문장으로 작성하는 것이 좋다. 또한 테스트 행위에 대한 결과를 기술하는데 도메인 용어를 사용하여 매서드 자체의 관점보다 도메인 정책 관점으로 한층 추상화된 내용을 담는것이 좋다. 마지막으로 테스트의 현상을 중점으로 기술하지 말자. 예를 들어 ~실패라기 보단 도메인의 내용을 담는것이 좋을 것 같다.

## BDD(Behavior Driven Development) 스타일로 작성하기

- TDD에서 파생된 개발방법
- 함수단위의 테스트에 집중하기보다 시나리오에 기반한 테스트 케이스(TC) 자체에 집중하여 테스트
- 개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 수준(레벨)을 권장

### Given / When / Then

- Given: 시나리오 진행에 필요한 모든 준비 과정(객체, 값, 상태 등)
- When: 시나리오 행동 진행
- Then: 시나리오 진행에 대한 결과 명시 및 검증

어떤환경에서(Given) 어떤 행동을 진행했을 때(When) 어떤 상태 변화가 일어난다.(Then)라는것을 토대로 @DisplayName을 상세히 적을 수 있다.