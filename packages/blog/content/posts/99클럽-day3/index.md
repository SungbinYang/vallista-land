---
title: "[99클럽] 면접반 3일차"
tags:
  - 면접
image: ./assets/banner.png
date: 2025-04-11 10:08:27
series: 면접
draft: false
---

![배너 이미지](./assets/banner.png)

> 📖 질문
>
> 분산 시스템 장애 복구
>
> 분산 시스템에서 서비스 장애나 노드 장애가 발생했을 때, 복구 전략이나 재시작 로직을 설계하면서 고려했던 요소와 실제 경험이 있다면 설명해주세요.
>
> 힌트: 장애 탐지 방법, 복구 전략(자동/수동), 데이터 정합성 유지 방법, 장애 전파 방지 등의 관점에서 설명해 보세요. 실제 경험이 없다면 학습한 내용이나 토이 프로젝트에서 고려했던 부분을 공유해도 좋습니다.

## 답변

분산 시스템에서의 장애 복구 전략에 대해 제 경험과 이론적인 지식을 바탕으로 답변드리겠습니다.

제가 직접 경험했던 사례로 사내 인트라넷 프로젝트에서 여러 시스템을 통합하는 JWT 기반 인증 시스템을 구축한 것입니다. 이 과정에서 분산 환경에서의 대응과 복구에 대해 많은 것을 배울 수 있는 기회였습니다.

제가 실제 장애 탐지 방법에 대해 구현했던 방식은 다음과 같습니다.

- 각 서비스에 `/health` 엔트포인트를 구현하여 중앙 모니터링 시스템에서 주기적으로 상태를 체크하였습니다. 
- ELK 스택을 활용한 로그 기반 모니터링으로 오류 패턴을 감지하였습니다. 
- RabbitMQ 큐 길이와 메세지 처리 실패율을 모니터링 하였습니다.

추가로 해당 방법론에 관심이 생겨서 이론적으로 더 학습을 해보았고 아래와 같이 여러 방법들을 찾아보았습니다.

분산 추적 시스템을 통하여 서비스 간 요청 흐름 모니터링을 할 수 있는 방법과 하트비트 매커니즘을 적용하여 노드 생존 여부를 확인할 수 있다는 것을 학습하였습니다. 또한 프로메테우스를 활용하여 이상 패턴을 감지하는 방식등 다양한 방식이 있다는 것을 알게 되었습니다. 해당 부분들은 현재 팀원분들과 논의중에 있고 동의가 되는데로 저희 시스템에 적용 할 예정입니다.

다음으로 복구 전략에 대해 말쓰믇리겠습니다.

실제 사내 인트라넷 프로젝트를 구축 및 운영을 하면서 실제 구현했던 전략은 다음과 같습니다.

- PM2와 Spring Boot의 자동 재시작 기능으로 미미한 장애에 대한 자동복구가 되도록 설정을 하였습니다.
- 중요 이벤트들은 저장소에 보관하여 서비스 복구 후 재처리하는 방식을 구현한 경험이 있습니다.
- 추가적으로 카나리 배포와 롤백 계획을 통하여 빠른 배포 및 신속한 복구를 통하여 복구 전략을 세웠습니다.

여기에 멈추지 않고 저는 이론적으로 추가적인 방식을 찾아보았습니다.

- 카나리 배포 대신 블루-그린 배포를 통하여 제로 다운타임 전환하는 방식을 알게되었고 현재 변경 예정입니다.
- 상태 기계 기반 복구 로직으로 단계적 복구 진행이 가능하다는 것을 알게 되었습니다.
- 체크 포인팅과 저널링을 통하여 상태복구가 가능하다는 것을 알게 되었습니다.

또한 데이터 정합성을 유지했던 방식도 말씀드리겠습니다. 실제 사내 인트라넷 프로젝트를 진행하면서 아래와 같이 구현을 진행하였습니다.

- 이벤트 기반 아키텍쳐와 RabbitMQ를 활용하여 비동기 데이터 동기화를 진행하였습니다.
- 멱등성 보장을 위한 이벤트 ID와 타임스탬프를 이용하였습니다.
- 이벤트 저장소를 통한 장애 후 데이터 재동기화를 진행하였습니다.
- 보상 트랜잭션으로 실패한 작업들을 롤백을 하여 데이터 정합성에 맞춰나갔습니다.

추가적으로 SAGA패턴을 통한 분산 트랜잭션 관리, 버저닝 기반 충돌 해결 및 롤백 매커니즘, CRDTs를 활용한 데이터 동기화, 쿼럼 기반 합의 알고리즘을 통한 일관성 보장등 다양한 방법들이 있는 것을 알게 되었고 해당 부분들에 대한 이론적인 지식들이 부족해 현재 학습 중에 있습니다.

마지막으로 장애 전파 방지에 대해 실제 사내 인트라넷 프로젝트에 적용했던 사례를 말씀드리겠습니다.

- 서비스 격리를 통한 장애 영향 범위를 제한하였습니다.
- Hystrix를 통하여 반복적인 실패를 관리하였습니다.
- 적절한 타임아웃을 설정하여 지연 전파를 방지하였습니다.
- Redis를 활용한 중앙화된 토큰 블랙리스트를 관리하는 방식으로 운영하였습니다.

추가적으로 벌크헤드 패턴을 통한 리소스 격리, 백프레셔 메커니즘을 통한 과부하 관리, 폴백 메커니즘을 통한 대체 응답 제공, 체인 및 매쉬패턴을 활용한 서비스 디스커버리 설계등 다양한 방식들을 찾아 보는 계기가 되었고 현재 해당 부분을 학습 예정입니다.

실제로 해당 프로젝트를 진행하면서 가장 큰 도전은  JWT 토큰 무효화와 권한 변경 시 데이터 일관성 유지였습니다. 이를 해결하기 위해 중앙 인증 서비스에서 로그아웃/권한 변경 이벤트를 발행하고 Rdis를 활용한 공유 토큰 블랙 리스트를 구현하였고 권한 변경 시 해당 사용자의 모든 활성 토큰 무효화 처리를 진행하였으며, 네트워크 장애에 대비해 이벤트 저장소를 구현하고 재처리 로직을 개발한 경험이 있습니다.

이 경험을 통해 분산 시스템에서는 **장애를 예외가 아닌 일상적인 상황으로 간주하고 설계해야 한다**는 원칙이 얼마나 중요한지 깨달았습니다. 완벽한 일관성보다는 비즈니스 요구사항에 맞는 적절한 수준의 일관성을 정의하고, 일시적인 불일치가 발생할 수 있는 시나리오를 명확히 이해하는 것이 중요했습니다.

비록 대규모 분산 시스템에서의 경험은 제한적이지만, 이 프로젝트를 통해 이론적으로 알고 있던 개념들을 실제로 적용해보며 실용적인 접근 방법과 트레이드오프를 이해할 수 있었습니다. 앞으로 더 복잡한 분산 시스템에서 이러한 원칙과 패턴을 적용하고 발전시켜 나가고 싶습니다.