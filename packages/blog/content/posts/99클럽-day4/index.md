---
title: "[99클럽] 면접반 4일차"
tags:
  - 면접
image: ./assets/banner.png
date: 2025-04-11 10:08:27
series: 면접
draft: false
---

![배너 이미지](./assets/banner.png)

> 📖 질문
>
> 데이터베이스 최적화 기법
>
> DB 인덱스, 샤딩, 복제 등의 기법을 활용해 성능을 개선한 경험이 있다면, 문제 상황과 적용 방식, 결과를 함께 설명해 주세요.
>
> 힌트: 쿼리 성능 문제를 어떤 방식으로 진단했고, 그에 따라 어떤 인덱스를 어떻게 설계했는지가 중요합니다. 단순히 "인덱스를 추가했다"보다는, 실행 계획(EXPLAIN) 분석이나 파티셔닝·샤딩을 통한 구조적 접근이 담기면 훨씬 설득력 있는 답변이 됩니다.

## 답변

안녕하세요. DB 성능 최적화 경험에 대해 말씀드리겠습니다.

### 페이지 성능 개선

제가 사내 코드 관리 시스템을 구축할 때 직면했던 가장 큰 문제 중 하나는 페이지 성능이였습니다. `EXPLAIN`으로 쿼리를 분석해보니 전통적인 `OFFSET-LIMIT`방식이 데이터가 많아질수록 심각한 성능 저하 문제가 발생한다는 것을 알 수 있었습니다.

이를 해결하기 위해 `No-Offset Query`패턴을 도입하였습니다. 아닌 이전 페이지의 마지막 ID를 기준으로 삼아서 아래와 같이 구현함으로써 DB가 불필요하게 앞의 데이터를 모두 스캔하는 문제를 해결했고 페이징 성능을 약 33% 개선할 수 있었습니다.

``` sql
SELECT * FROM code_table
WHERE id > :lastSeenId
ORDER BY id ASC LIMIT 20;
```

### 인덱스 최적화

또 다른 사례로, 회의실 예약 시스템에서도 쿼리 최적화를 진행했습니다. 여기서는 예약 정보를 조회할 때 불필요한 JOIN을 줄이고, 쿼리 패턴을 분석한 후 최적의 복합 인덱스를 설계하였습니다. 특히 자주 사용되는 필터 순서를 고려하여 `reservation_date, room_id`와 같은 복합 인덱스를 생성했고, 이를 통해 예약 조회 쿼리 성능을 약 30% 개선했습니다.

여기서 단순히 인덱스를 추가하는 것이 아니라, 실제 쿼리 패턴을 분석하고 그에 맞게 인덱스를 설계하는 것입니다. 이는 `EXPLAIN` 분석을 통하여 각 쿼리가 어떤 인덱스를 사용하는지 확인하는 과정을 거쳤습니다.

### 동시성 제어

회의실 예약 시스템에서는 또한 동시 예약 충돌 문제가 있었습니다. 이를 해결하기 위해 Spring Data JPA의 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 활용한 비관적 락을 구현하였습니다. 이를 통해 동일 시간대에 동시 예약이 발생할 수 없도록 보장했고 사용자 경험을 해치지 않으면서도 데이터 무결성을 유지할 수 있었습니다.

이러한 경험을 통해 DB 성능 최적화는 단순한 인덱스 추가로만 끝나는게 아니라 데이터 접근 패턴에 대한 이해와 다양한 기법의 조합이 중요하다는 것을 배웠습니다. 현재는 단일 서버 환경에서의 최적화에 중점을 두었지만 앞으로는 대용량 트래픽을 처리하기 위한 샤딩, 복제등의 기술도 학습하고 적용해보고 싶습니다.

특히 최근에는 인프랩에서 주최한 워밍업 클럽을 통해 학습한 클린코드와 테스트 기법을 활용하여, 성능뿐만 아니라 유지보수성도 고려한 설계를 지향하고 있습니다.