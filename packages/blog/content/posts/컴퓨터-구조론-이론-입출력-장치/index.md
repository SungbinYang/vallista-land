---
title: "[컴퓨터 구조론 이론] 입출력 장치"
tags:
  - cs
image: ./assets/banner.png
date: 2026-02-26 18:56:27
series: 컴퓨터 구조론 이론
draft: false
---

![banner](./assets/banner.png)

> 본 포스팅은 인프런의 [개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터구조 + 운영체제](https://inf.run/6vJaw)를 참조하여 작성한 글입니다.

## 장치 컨트롤러와 장치 드라이버

컴퓨터에는 CPU와 메모리만 있지 않다. 스피커, 모니터, 키보드, 마우스등과 같은 입출력 장치와 외장 하드디스크나 USB 메모리등 보조기억 장치가 컴퓨터에 장착되어 있다. 이번에는 **장치 컨트롤러** 와 **장치 드라이버** 라는 개념을 통해 다양한 외부 장치가 컴퓨터에 어떻게 연결되고 소통하는지 알아보도록 하자.

### 장치 컨트롤러

입출력 장치는 CPU, 메모리보다 다루기가 더 까다롭다. 이유는 여러가지가 존재한다.

첫째, 입출력 장치에는 종류가 너무 많다. 장치가 다양하면 장치마다 속도, 데이터, 전송 형식등도 다양하다. 다양한 입출력 장치나 정보를 주고 받는 방식을 규격화하기 어렵기 때문이다. 둘째, 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력 장치의 데이터 전송률은 낮기 때문이다.

> 전송률이란, 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표이다.

이와 같은 이유로 입출력 장치는 컴퓨터에 직접 연결되지 않고 장치 컨트롤러라는 하드웨어를 통해 연결된다. 장치 컨트롤러는 입출력 제어기, 입출력 모듈등으로 다양하게 불리기도 하는데 여기서는 장치 컨트롤러라고 말하겠다. 장치 컨트롤러의 역할을 조금 더 구체적으로 알아보자. 장치 컨트롤러는 대표적으로 다음과 같은 역할을 통해 앞에서 언급한 문제들을 해결한다.

- CPU와 입출력 장치 간의 통신 중개 <- 일종의 번역가 역할
- 오류 검출
- 데이터 버퍼링

여기서 버퍼링이란, 전송률이 높은 장치와 낮은 장치 사이에 주고 받은 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법을 말한다.

이번에는 장치 컨트롤러의 내부 구조를 살펴보자. 장치 컨트롤러 내부는 복잡하지만 대표적으로 **데이터 레지스터** 와 **상태 레지스터** , **제어 레지스터** 3가지가 존재한다.

> 상태 레지스터와 제어 레지스터는 하나의 레지스터로 사용되기도 한다.

데이터 레지스터는 CPU와 입출력 장치 사이에 주고 받을 데이터가 담기는 레지스터로 일종의 버퍼 역할을 한다. 하지만 요즘 현대에 와서 주고 받는 데이터의 양이 많아져 RAM을 사용하기도 한다.

상태 레지스터는 상태 정보를 저장하는데 입출력 장치가 입출력 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지, 입출력 장치에 오류가 없는지 등의 상태 정보를 저장한다.

제어 레지스터는 입출력 장치가 수행할 내용에 대한 제어 정보를 저장한다.

### 장치 드라이버

다음은 장치 드라이버에 대해 알아보자. 장치 드라이버는 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램을 뜻한다. 장치 컨트롤러가 입출력 장치를 연결하기 위한 하드웨어적인 통로라면 장치 드라이버는 입출력 장치를 연결하기 위한 소프트웨어적 통로로 보면 좋다. 컴퓨터가 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 그 장치는 어떤 회사에서 만들어진 제품이든, 생김새가 어떻든 상관없이 컴퓨터 내부와 정보를 주고 받을 수 있다. 반대로 장치 드라이버를 인식하거나 실행할 수 없는 상태라면 그 장치는 컴퓨터 내부와 정보를 주고 받을 수 없다.

## 다양한 입출력방법

입출력 작업을 수행하려면 CPU와 장치 컨트롤러가 정보를 주고 받아야 한다. 그러면 장치 컨트롤러는 CPU와 어떻게 정보를 주고 받을까? 여기에는 크게 3가지 방법이 존재한다. **프로그램 입출력** , **인터럽트 기반 입출력** , **DMA 입출력** 이다.

### 프로그램 입출력

프로그램 입출력이란, 프로그램 속 명령어로 입출력 장치를 제어하는 방법을 말한다. 입출력 명령어로써 장치 컨트롤러와 상호작용을 한다. 메모리에 저장된 정보를 하드 디스크에 백업하는 상황을 생각해보자. 그러면 아마 아래의 과정으로 입출력 작업을 할 것이다.

- 우선 CPU는 하드 디스크 컨트롤러의 제어 레지스터와 쓰기 명령을 보낸다.
- 하드 디스크 컨트롤러는 하드 디스크 상태를 확인한다. 이것은 즉, 상태 레지스터에 준비 완료 표시를 하는 것과 같다.
- CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인한다. 하드 디스크가 준비됐음을 CPU가 알게 되면 백업할 메모리의 정보를 데이터 레지스터에 쓴다. 만약 아직 백업 작업이 끝나지 않았다면 첫번째 순서부터 다시 반복한다. 쓰기가 끝났다면 작업을 종료한다.

이렇듯 프로그램 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다. 그런데 CPU는 어떻게 입출력 장치의 주소들을 알까? 정확히 말해 CPU는 장치 컨트롤러의 레지스터들을 어떻게 알까? CPU 내부에 있는 레지스터들과는 달리 CPU는 여러 장치 컨트롤러 속 레지스터들은 모두 알고 있기란 어렵다. 그렇다면 아래와 같은 명령어들은 어떻게 명령어로 표현되고 메모리에 어떻게 저장되어 있을까?

여기에는 크게 2가지 방식이 존재한다. 바로 **메모리 맵 입출력** 과 **고립형 입출력** 이다.

메모리 맵 입출력은 메모리에 접근하기 위한 주소공간과 입출력 장치에 접근하기 위한 주소공간을 하나의 주소 공간으로 간주하는 방법을 말한다. 가령 1024개의 주소를 표현할 수 있는 컴퓨터가 있을 때 1024개 전부 메모리 주소를 표현하는데 사용하지 않는다. 512개는 메모리 주소를, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용하는 것이다. 그리고 특정 장치 컨트롤러의 특정 번지를 지정하는 것이다. 그렇다면 CPU는 특정 번지를 읽어들여라는 명령어로 장치 컨트롤러의 상태를 읽을 수 있다.

이때 중요한 점은 메모리 맵 입출력 방식에서 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다는 점이다. 그래서 메모리에 접근하는 명령어와 입출력 장치에 접근하는 명령어는 굳이 다를 필요가 없다.

고립형 입출력 방식은 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법이다. 제어버스에 메모리 읽기/쓰기 선 이외에 입출력 장치 읽기/쓰기 선이 따로 있다면 메모리 1024개의 주소 공간을 활용하고 입출력 장치도 1024개의 주소 공간을 활용할 수 있다. 고립형 입출력 방식에서는 CPU는 입출력 장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른 입출력 명령어를 사용한다.

### 인터럽트 기반 입출력

하드웨어 인터럽트란, 일종의 알림으로 플래그 레지스터 속 인터럽트 비트를 이용하여 판단하며 인터럽트 요청 신호를 받으면 인터럽트 서비스 루틴을 실행시킨다고 말했다. 이렇게 장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행한다. 이렇게 인터럽트 기반으로 하는 입출력을 인터럽트 기반 입출력이라고 한다.

이번에는 조금 더 일반적인 입출력 장치가 많을 때를 생각해보자. 여러 입출력 장치에서 인터럽트가 동시에 발생한 경우에는 인터럽트를 어떻게 처리할까? 가장 쉽게는 인터럽트 발생 순서대로 처리할 수 있을 것이다. 플래그 레지스터 속 인터럽트 비트를 비활성화 한채 한쪽 인터럽트를 처리하고 다음 인터럽트를 처리하는 식으로 할 수 있을 것이다.

하지만 현실적으로는 모든 인터럽트를 전부 순차적으로만 해결할 수 없다. 인터럽트 중에서도 더 빨리 처리해야 하는 인터럽트가 있기 때문이다. 즉, CPU는 인터럽트간에 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리할 수 있다. 예를 들어서 A라는 인터럽트가 들어와서 인터럽트 서비스 루틴을 실행 중에 B라는 우선순위가 높은 인터럽트가 왔을 때 해당 인터럽트를 중지하고 B라는 인터럽트를 수행하는 방식이다. 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 NMI가 발생한 경우 CPU는 이렇게 우선순위가 높은 인터럽트부터 처리한다.

우선순위를 반영하여 다중 인터럽트를 처리하는 방법에는 여러가지가 있지만 많은 컴퓨터에서 PIC라는 하드웨어를 많이 사용한다. PIC는 여러 장치 컨트롤러에 연결되어 장치 컨트롤러의 하드웨어 인터럽트 우선순위를 판단한 뒤 CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어를 말한다.

> NMI 우선순위까지는 판단하지 않는다.

PIC의 다중 인터럽트 처리 과정은 다음과 같다.

- PIC가 장치 컨트롤러에서 인터럽트 요청 신호들을 받아들인다.
- PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다.
- CPU는 PIC에 인터럽트 확인 신호를 보낸다.
- PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다.
- CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고 해당 장치의 인터럽트 서비스 루틴을 실행한다.

### DMA 입출력

프로그램 기반 입출력과 인터럽트 기반 입출력에서 공통점이 있다면 입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다는 점이다. CPU는 가뜩이나 바쁜데 하드디스크 백업과 같이 대용량 데이터를 이동한다면 어떻게 할까? CPU는 입출력장치를 위한 연산 때문에 시간을 뺏기게 된다. 하드 디스크 백업과 같이 대용량 데이터를 옮길 때는 CPU는 부담이 될 것이다. 그래서 입출력 장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식인 DMA가 등장했다. DMA는 이름 그대로 직접 메모리에 접근할 수 있는 입출력 기능이다. DMA 입출력을 하기 위해서는 시스템 버스에 연결된 DMA 컨트롤러가 필요하다.

> DMA: CPU를 거치지 않고 입출력 장치가 메모리에 직접적으로 접근하는 기능

일반적으로 DMA 입출력은 아래와 같다.

- CPU는 DMA 컨트롤러에 입출력 장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소등과 같은 정보로 입출력 작업을 명령한다.
- DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다. 이 때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다. 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근한다.
- 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝남을 알린다.

즉, CPU는 입출력 작업의 시작과 끝만 관여를 하는 것이다. 앞서 설명한 DMA 과정에서 시스템 버스를 이용한다. 그런데 시스템 버스는 공용자원이기 때문에 동시에 사용이 불가능하다. CPU가 시스템 버스를 사용할 때 DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU가 시스템 버스를 사용 못한다. DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을때마다 조금씩 시스템 버스를 이용한다. CPU가 일시적으로 시스템 버스를 이용하지 않도록 양해를 구하고 이용하는 셈이다.

그러면 장치 컨트롤러가 시스템 버스에는 직접 연결해도 괜찮을까? 위와 같은 동시에 사용하면 안된다는 것이 걸린다. 또한 DMA 과정에서 시스템 버스를 불필요하게 2번 이용하게 된다. 이러한 문제는 DMA 컨트롤러와 장치 컨트롤러들의 입출력 버스라는 별도의 버스에 연결하여 해결이 가능하다. 입출력 버스에는 PCI 버스, PCI Express 버스등 여러 종류가 있다.

> 여러 입출력 장치들을 PCIe 버스와 연결해주는 통로가 바로 PCIe 슬롯이다.