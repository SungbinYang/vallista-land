---
title: "[자바 고급3] 람다 vs 익명 클래스"
tags:
  - 자바
image: ./assets/banner.png
date: 2025-06-01 00:11:27
series: 자바 고급3
draft: false
---

![배너 이미지](./assets/banner.png)

> 해당 블로그 글은 [영한님의 인프런 강의](https://inf.run/ZEStF)를 바탕으로 쓰여진 글입니다.

## 람다 vs 익명 클래스1

자바에서 **익명 클래스**와 **람다 표현식**은 모두 간단하게 기능을 구현하거나, 일회성으로 사용할 객체를 만들 때 유용하지만, 그 사용 방식과 의도에는 차이가 있다.

### 문법 차이

#### 익명 클래스

``` java
Button button = new Button();

button.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        System.out.println("버튼 클릭");
    }
});
```

- 익명 클래스는 클래스를 선언하고 즉시 인스턴스를 생성하는 방식이다.
- 반드시 `new 인터페이스명() { ... }` 형태로 작성해야 하며, 메서드를 오버라이드해서 구현한다.
- 익명 클래스도 하나의 클래스이다.

#### 람다

``` java
Button button = new Button();
button.setOnClickListener(v -> System.out.println("버튼 클릭"));
```

- 람다 표현식은 함수를 간결하게 표현할 수 있는 방식이다.
- 함수형 인터페이스(메서드가 하나인 인터페이스)를 간단히 구현할 때 주로 사용한다.
- 람다는 `->` 연산자를 사용하여 표현하며, 매개변수와 실행할 내용을 간결하게 작성할 수 있다.
- 물론 람다도 인스턴스가 생성된다.

### 코드 간결함

- **익명 클래스**는 문법적으로 더 복잡하고 장황하다. `new 인터페이스명()` 같은 형태와 함께 메서드를 오버라이드 해야 하므로 코드의 양이 상대적으로 많다.
- **람다 표현식**은 간결하며, 불필요한 코드를 최소화한다. 또한 많은 생략 기능을 지원해서 핵심 코드만 작성할 수 있다.

### 상속 관계

- **익명 클래스**는 일반적인 클래스처럼 다양한 인터페이스와 클래스를 구현하거나 상속할 수 있다. 즉, 여러 메서드를 가진 인터페이스를 구현할 때도 사용할 수 있다.
- **람다 표현식**은 메서드를 딱 하나만 가지는 **함수형 인터페이스**만을 구현할 수 있다.
    - 람다 표현식은 **클래스를 상속**할 수 없다. 오직 함수형 인터페이스만 구현할 수 있으며, **상태(필드, 멤버 변수)**나 추가적인 메서드 오버라이딩은 불가능하다.
    - 람다는 단순히 함수를 정의하는 것으로, 상태나 추가적인 상속 관계를 필요로 하지 않는 상황에서만 사용할 수 있다.

### 호환성

- **익명 클래스**는 자바의 오래된 버전에서도 사용할 수 있다.
- **람다 표현식**은 자바 8부터 도입되었기 때문에 그 이전 버전에서는 사용할 수 없다.

### this 키워드 의미

- **익명 클래스** 내부에서 `this`는 익명 클래스 자신을 가리킨다. 외부 클래스와 별도의 컨텍스트를 가진다.
- **람다 표현식**에서 `this` 는 람다를 선언한 클래스의 인스턴스를 가리킨다. 즉, 람다 표현식은 별도의 컨텍스트를 가지는 것이 아니라, 람다를 선언한 클래스의 컨텍스트를 유지한다.

### 캡쳐링

#### 익명 클래스

- 익명 클래스는 외부 변수에 접근할 수 있지만, 지역 변수는 반드시 `final` 혹은 **사실상 final**인 변수만 캡처할 수 있다.

#### 람다

- 람다도 익명 클래스와 같이 캡처링을 지원한다. 지역 변수는 반드시 `final` 혹은 **사실상 final**인 변수만 캡처할 수 있다.

## 람다 vs 익명 클래스2

### 생성 방식

- 익명 클래스
    - 익명 클래스는 새로운 클래스를 정의하여 객체를 생성하는 방식이다. 즉, 컴파일 시 새로운 내부 클래스로 변환된다. 예를 들어 `OuterClass$1.class`와 같이 이름이 지정된 클래스 파일이 생성된다.
    - 이 방식은 클래스가 메모리 상에서 별도로 관리되므로, 메모리 상에 약간의 추가 오버헤드가 발생한다.
- 람다
    - 람다는 내부적으로 `invokeDynamic`이라는 메커니즘을 사용하여 컴파일 타임에 실제 클래스 파일을 생성하지 않고, 런타임 시점에서 동적으로 필요한 코드를 처리한다.
    - 따라서 람다는 익명 클래스보다 메모리 관리가 더 효율적이며, 생성된 클래스 파일이 없으므로 클래스 파일 관리의 복잡성도 줄어든다.

그럼 생성 부분을 어떻게 되는지 가상의 코드로 한번 살펴보자.

``` java
public class FunctionMain {
    public static void main(String[] args) {
        Function<String, Integer> function = x -> x.length();
        System.out.println("function1 = " + function.apply("hello"));
    }
}
```

위와 같은 람다가 포함된 코드가 있다. 이 람다는 컴파일 이후에 런타임에 `invokeDynamic`을 이용하여 아래와 같아 변경 된다.

``` java
public class FunctionMain {
    public static void main(String[] args) {
        Function<String, Integer> function = 람다 인스턴스 생성(구현 코드는 lambda1() 연결)
        System.out.println("function1 = " + function.apply("hello"));
    }
    // 람다를 private 메서드로 추가
    private Integer lambda1(String x) {
        return x.length();
    }
}
```

- 컴파일 단계에서 람다를 별도의 클래스로 만드는 것이 아니라, `private` 메서드로 만들어 숨겨둔다.
    - 참고로 자바 내부에서 일어나는 일이므로 개발자가 이렇게 만들어진 코드를 확인하기는 어렵다.
- 그리고 실행 시점에 동적으로 람다 인스턴스를 생성하고, 해당 인스턴스의 구현 코드로 앞서 만든 `lambda1()` 메서드가 호출되도록 연결한다.

### 상태 관리

- 익명 클래스
    - 익명 클래스는 인스턴스 내부에 **상태(필드, 멤버 변수)**를 가질 수 있다. 예를 들어, 익명 클래스 내부에 멤버 변수를 선언하고 해당 변수의 값을 변경하거나 상태를 관리할 수 있다.
- 람다
    - 클래스는 그 내부에 **상태(필드, 멤버 변수)**와 **기능(메서드)**을 가진다. 반면에 함수는 그 내부에 **상태(필드)**를 가지지 않고, 기능만 제공한다.
    - 함수인 람다는 기본적으로 필드(멤버 변수)가 없으므로 스스로 **상태를 유지하지는 않는다**.

### 익명 클래스와 람다 용도 구분

- 익명 클래스
    - **상태를 유지**하거나 다중 메서드를 구현할 필요가 있는 경우
    - 기존 클래스 또는 인터페이스를 상속하거나 구현할 때
    - 복잡한 인터페이스 구현이 필요할 때
- 람다
    - **상태를 유지할 필요가 없고**, 간결함이 중요한 경우
    - 단일 메서드만 필요한 간단한 함수형 인터페이스 구현 시
    - 더 나은 성능(이 부분은 미미함)과 간결한 코드가 필요한 경우

> 잘못된 지식이 있을 경우 댓글로 남겨주시면 빠르게 반영하겠습니다!