---
title: "[자바 입문] 스코프, 형변환"
tags:
  - 자바
image: ./assets/banner.png
date: 2025-04-19 17:26:27
series: 자바
draft: false
---

![배너 이미지](./assets/banner.png)

> 해당 블로그 글은 [영한님의 인프런 강의](https://inf.run/WUc1V)를 바탕으로 쓰여진 글입니다.

## 스코프1 - 지역 변수와 스코프

변수는 선언된 위치에 따라서 지역변수, 멤버변수로 분류된다. 우리가 이제까지 사용했던 변수는 전부 지역변수이다.

지역변수는 특정 지역에서만 사용하는 변수를 뜻한다. 여기서 특정 지역이라고 하는 것은 코드블럭(`{}`)을 뜻한다. 지역변수는 자신이 선언된 코드블럭에서만 사용이 가능하고 이를 벗어나면 사용을 할 수 없다.

``` java
package scope;

public class Scope2 {
    public static void main(String[] args) {
        int a = 100;

        for (int i = 0; i < 10; i++) {
            System.out.println(a);
            System.out.println(i);
        }

//        System.out.println(i); 사용불가
        System.out.println(a);
    }
}
```

지역변수 a는 main 메서드 코드블럭에 속한다. 따라서 main 메서드 전반에 걸쳐서 사용이 가능하다. 하지만 for문에서 선언한 변수 i는 for문 안에서만 사용이 가능하다. 이를 벗어나면 아래와 같은 컴파일 에러가 발생한다.

``` bash
cannot find symbol
```

이렇게 변수의 접근 가능한 범위를 스코프(Scope)라 한다. 이를 비유적으로 좀 표현해보자. 지역변수를 군인이라고 생각해보자. 지역변수 선언은 입대를 의미한다. 입대를 하면 소속된 부대에서 활동을 해야한다. 이를 벗어나면 탈영이다. 탈영했다라고 알림이 나오는 것을 자바에서는 컴파일 에러로 처리를 하는 것이다.

## 스코프2 - 스코프 존재 이유

그러면 왜 스코프라는 개념이 도입이 된 걸까? 사실 자유롭게 변수를 선언하면 어디서든 쓸 수 있게 하면 사용자 입장에서는 정말 좋을 것이다. 하지만 이렇게 제약을 둔 이유가 존재한다.


- **비효율적인 메모리 사용**: 특정 코드블록에서만 사용하는 지역변수를 전체 스코프로 둔다면 메모리 낭비가 발생한다. 만약 특정 코드블록에서만 선언하면 그 코드블록이 종료되는 시점에 변수에 할당한 메모리 자원이 반환된다. 이렇게 효율적으로 메모리를 사용할 수 있으나 스코프 개념이 없다면 비효율적인 낭비가 될 것이다.

그런데 이전에 필자가 이렇게 말했을 것이다. 메모리 자원은 싸니까 괜찮지 않을까? 그렇다. 메모리 자원은 싸다. 그래서 어디서 선언을 해도 무방은 하다. 하지만 스코프를 둔 가장 큰 이유는 아래의 이유때문이라고 생각한다.

- **코드 복잡성 증가**: 좋은 코드는 군더더기 없는 단순한 코드이다. 스코프 개념이 없고 특정 코드블록에서만 사용하는 지역변수를 더 넓은 스코프의 코드블록에 선언한다면 개발자가 작성하면서 항상 생각을 해야한다. 언제 이 변수를 쓸지 모르니까 말이다. 하지만 특정 코드블록에서만 선언한다면 그 블록에서만 생각을 하고 나머지 영역에서는 생각을 안 해도 된다. 지금까지는 코드가 매우 단순해서 이해하는데 어려움이 없겠지만 실무에서는 코드가 매우 복잡한 경우가 많다.

### while문과 for문의 스코프

이 변수의 스코프를 이야기하면 `while`문과 `for`문이 생각이 든다. [반복문 포스팅](https://sungbin.kr/반복문/)때 잠깐 이야기를 한 적이 있다. 일부 코드를 살펴보자.

``` java
int i = 1;
int count = 1;

while (i < 10) {
    count += 2;
    i++;
}

System.out.println(count);
```

위의 코드는 `while`문을 이용한 코드이다. 여기서 변수 i는 while문 코드블록에서만 사용한다. 하지만 코딩을 읽을 때 읽는 사람 입장에서는 변수 i는 항상 신경써야 한다. 언제 쓸지 모르니까 말이다. 즉 너무 비효율적이다.

``` java
int count = 1;

for (int i = 1; i < 10; i++) {
    count += 2;
}
```

반면에 위의 `for`문은 변수 i는 딱 for문 코드 블록에서만 신경쓰면 된다. 효율적이다라고 생각이 들 것이다. 그래서 이전에 왜 실무에서 for문을 많이 쓰는지 알 수 있을 것이다. 이런 측면이 한 몫을 해주는 것이다.

### 정리

- 변수는 꼭 필요한 범위로 한정해서 사용하는 것이 좋다. 변수의 스코프는 꼭 필요한 곳으로 한정해서 사용하자. 메모리를 효율적으로 사용하고 더 유지보수하기 좋은 코드를 만들 수 있다.

- 좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.

## 형변환1 - 자동 형변환

### 형변환

작은 범위에서 큰 범위로 당연히 값을 넣을 수 있다. 쉽게 생각해서 큰 비닐봉지에 작은 비닐봉지들을 담을 수 있는 것처럼 말이다. 하지만 반대로 큰 범위에서 작은 범위의 대입은 문제가 발생한다. (소수점 버림, 오버플로우) 코드를 통해 살펴보자.

``` java
int integerValue = 100;
long longValue = integerValue; // 100
double doubleValue = longValue; // 100.0
```

이렇게 해도 에러 없이 잘 동작한다. 그 이유는 int가 long보다 범위가 작고 long이 double보다 범위가 작기 때문이다. 그래서 이렇게 대입하는 것은 문제가 없다.

> ✅ 참고
>
> 단, 대입하는 타입의 형식은 맞춰줘야 한다. 정수 100이 들어가도 타입이 실수이면 실수형으로 맞춰줘야 한다. 마치 아이스박스에 생선이 들어가는데 그 생선을 종이박스에 담으려한다면 비닐봉지로 감싸서 넣어야 하는 것처럼 말이다.

### 자동 형변환

이런것을 자바에서 자동 형변환이라고 한다.

``` java
intValue = 100
doubleValue = intValue
doubleValue = (double) intValue //형 맞추기
doubleValue = (double) 100 //변수 값 읽기
doubleValue = 100.0 //형변환
```

작은 범위 숫자 타입에서 큰 범위 숫자 타입으로의 대입은 개발자가 이렇게 직접 형변환을 하지 않아도 된다. 이런 과정
이 자동으로 일어나기 때문에 **자동 형변환**, 또는 **묵시적 형변환**이라 한다.

## 형변환2 - 명시적 형변환

큰 범위에서 작은 범위 대입은 명시적 형변환이 필요하다.

``` java
double doubleValue = 3.14;
int intValue = 0;

// intValue = doubleValue; //오류 발생
intValue = (int) doubleValue; //형변환
```

큰 범위의 값을 작은 범위의 타입에 대입은 불가능하다. 따라서 이에 맞게 형변환이 필요하다. 그렇지 않으면 아래와 같이 에러가 발생한다.

``` bash
java: incompatible types: possible lossy conversion from double to int
```

쉽게 이야기 하자면 큰 아이템을 작은 에코백에 담을 수 없다. 만약 억지로 담을려고 한다면 그 아이템을 에코백 크기에 맞게 쪼개서 담아야 한다.

비유에 든 것처럼 아이템을 쪼개야 하기 때문에 자바에서는 컴파일 에러를 넣어준 것이다. 그럼에도 불구하고 해야한다면 `()` 연산자를 통해서 캐스팅을 해줄 수 있다. 이런 것을 명시적 형변환이라고 한다.

### 형변환과 오버플로우

형변환을 할 때 만약 범위를 벗어난다면 어떻게 할까?

``` java
long maxIntValue = 2147483647; //int 최고값
long maxIntOver = 2147483648L; //int 최고값 + 1(초과)
int intValue = 0;

intValue = (int) maxIntValue; //형변환

intValue = (int) maxIntOver; //형변환
```

위와 같은 코드가 있을 때 결과가 어떻게 될까? 첫번째 intValue는 값이 잘 출력이 될 것이다. 하지만 2번째 intValue에는 `-2147483648`라는 값이 나올 것이다. 왜냐하면 int형에 담을 수 있는 크기가 2147483647까지인데 이것을 넘어갔으니 int형에 담을 수 있는 최소 크기로 변환 한 것이다.

``` java
maxIntOver = 2147483648L; //int 최고값 + 1
intValue = (int) maxIntOver; //변수 값 읽기
intValue = (int) 2147483648L; //형변환 시도
intValue = -2147483648;
```

그래서 결론적으로 중요한 것은 오버플로우가 발생하는 것 자체가 문제라는 점이다. 오버플로우가 발생했을 때 결과가 어떻게 되는지
계산하는데 시간을 낭비하면 안된다. 오버플로우 자체가 발생하지 않도록 막아야 한다.

## 계산과 형변환

계산을 할 때도 타입 형변환이 일어난다.

``` java
int div1 = 3 / 2; // 1

double div2 = 3 / 2; // 1.0

double div3 = 3.0 / 2; // 1.5

double div4 = (double) 3 / 2; // 1.5
```

위와 같이 계산을 하면 결과 값은 주석으로 써놓았다. 어떻게 이렇게 결과 값이 나올까? 아래의 과정을 살펴보면 이해가 될 것이다.

``` java
int div1 = 3 / 2; //int / int
int div1 = 1; //int / int이므로 int타입으로 결과가 나온다.

double div2 = 3 / 2; //int / int
double div2 = 1; //int / int이므로 int타입으로 결과가 나온다.
double div2 = (double) 1; //int -> double에 대입해야 한다. 자동 형변환 발생
double div2 = 1.0; // 1(int) -> 1.0(double)로 형변환 되었다.

double div3 = 3.0 / 2; //double / int
double div3 = 3.0 / (double) 2; //double / int이므로, double / double로 형변환이 발생한
다.
double div3 = 3.0 / 2.0; //double / double -> double이 된다.
double div3 = 1.5;

double div4 = (double) 3 / 2; //명시적 형변환을 사용했다. (double) int / int
double div4 = (double) 3 / (double) 2; //double / int이므로, double / double로 형변
환이 발생한다.
double div4 = 3.0 / 2.0; //double / double -> double이 된다.
double div4 = 1.5;
```

리터럴도 타입이 있기에 리터럴 타입 기준으로 계산을 한 결과이다. 그러면 이것을 암기해야 할까? 이것을 암기하지 말고 2가지 원칙을 기억해보자.

- 같은 타입끼리의 계산은 같은 타입의 결과를 낸다.
- 서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어난다.

> 잘못된 지식이 있을 경우 댓글로 남겨주시면 빠르게 반영하겠습니다!