---
title: "[오브젝트] 객체지향 기본 원칙"
tags:
  - 자바
image: ./assets/banner.png
date: 2025-06-11 19:40:27
series: 오브젝트
draft: false
---

![배너 이미지](./assets/banner.png)

> 해당 블로그 글은 [조영호님의 인프런 강의](https://inf.run/eUUx4)를 바탕으로 쓰여진 글입니다.

## 객체지향 설계 원칙

설계란 무엇일까? 설계란 코드를 배치하는 방식을 의미한다. 그럼 좋은 설계란 무엇일까? 코드를 더 이해하기 쉽고 변경에 용이하게 코드를 배차하는 것읠 의미한다. 우리가 이전에 살펴본 절차지향적 설계를 개선한 것이 바로 좋은 설계를 위한 것이라고 생각한다.

그러면 설계는 왜 필요할까? 바로 요구사항이 변경되거나 리팩토링을 할 때 코드를 쉽고 안전하게 수정하기 위해서이다. 여기서 객체지향의 핵심을 알 수 있다. 바로 **변경 관리**라는 것이다. 변경을 쉽고 용이하게 하는 것이 바로 객체지향의 시작이다. 그러면 객체지향이 말하는 설계 원칙을 자세히 살펴보자. 한줄로 나타내면 아래와 같이 표현할 수 있을 것이다.

- 협력에 필요한 행동을 먼저 결정하고 행동에 적합한 객체를 나중에 선택하라
- 객체의 행동을 먼저 구현하고 행동에 필요한 데이터를 나중에 선택하라

그러면 위의 원칙 중에 **객체의 행동을 먼저 구현하고 행동에 필요한 데이터를 나중에 선택하라**를 살펴보자. 이전 절차지향적 설계에는 데이터와 프로세스를 서로 다른 모듈로 분리하여 독립적인 데이터 설계를 진행하였다. `private`으로 캡슐화인척을 하더라도 `getter/setter`를 통하여 데이터를 그대로 외부에 노출시켰다. 이로 인하여 데이터 내부 구조를 변경함에 있어서 외부 프로세스에 그대로 영향을 미치게 되었다. 그래서 우리는 데이터와 프로세스를 합치므로서 데이터를 책임지는 로직을 데이터 안에 넣어두었다. 즉, 데이터 그 자체를 의존하는 것이 아닌 행동에 의존시켰다. 그래서 이런 좋은 설계를 할 때 가장 먼저 생각하는 것이 데이터는 일단 무시하고 이 객체가 외부에 어떤 역할을 해주고 제공해줘야 할 지 행동을 먼저 생각해야 한다. 그리고 해당 행동을 구현하면서 필요한 데이터를 나중에 추가를 해야 한다. 그럼 이런 행동을 작성하는 기준이 있을까? 앞서 이야기를 했지만 이 행동이 외부에 사용이 될까를 고민해야 한다.

두번째로 **협력에 필요한 행동을 먼저 결정하고 행동에 적합한 객체를 나중에 선택하라**를 살펴보자. 고립된 상태의 클래스의 행동을 선택하는 것은 불가능하다. 객체의 행동은 협력에 필요한 요청에 의해서 행동을 결정해야 한다. 그 다음에 이런 행동에 필요한 협력 객체를 결정해야 할 것이다. 그리고 마지막으로 행동을 구현하면서 구현에 적합한 데이터를 결정하는 것이다.

객체지향 설계는 제한된 문맥 안에서 설계가 되어야 한다. 그리고 협력이라는 것이 이런 문맥을 제공해준다. 즉, 객체지향 원칙을 조금 쉽게 말하면 **수정하기 쉬운 코드를 만드는 원칙**이라고 생각하면 될 것이다.

그래서 우리가 객체지향 원칙을 기반으로 설계를 하려면 먼저 **객체의 행동을 먼저 구현하고 행동에 필요한 데이터를 나중에 선택**하고 그 후에 **협력에 필요한 행동을 먼저 결정하고 행동에 적합한 객체를 나중에 선택**해야 한다. 즉, 객체 사이의 협력을 기반으로 클래스 내부를 구현해야 한다는 의미이다.

정리를 하자면 객체 협력(런타임)에서 클래스 구조(컴파일 타임) 순으로 진행되어야 한다. 이것이 바로 책임 주도 개발인셈이다.

## 책임 주도 설계

객체 지향의 설계 흐름은 다음과 같다.

- 협력을 위한 문맥 결정
- 필요한 책임을 식별
- 책임을 수행할 객체 선택
- 책임 구현
- 데이터 결정

> 📚 용어 정리
>
> 책임: 협력에 참여하기 위해 객체가 수행해야 하는 행동

책임은 즉, 행동 관점으로 바라보면 아래와 같이 2가지로 분류할 수 있다.

- 하는 것
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    - 다른 객체(협력자)의 행동을 시작시키는 것
    - 다른 객체(협력자)의 활동을 제어하고 조절하는 것
- 아는 것
    - private로 캡슐화된 상태(데이터)에 대해 아는 것
    - 관련된 객체(협력자)에 관하여 아는 것
    - 자신이 유도하거나 계산할 수 있는 것(상태와 협력자)에 관하여 아는 것

그러면 책임 주도 설계 과정을 살펴보자. 여기서 책임은 객체간 협력을 위한 행동의 정의인데 이것은 바로 우리 서비스의 비즈니스 요구사항과 동일하다. 그러면 책임 주도 설계 과정을 보면 아래와 같다.

- 애플리케이션이 제공할 기능 파악
- 애플리케이션의 기능 요구사항을 시스템 책임으로 변환
- 시스템의 책임을 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움 요청
- 이 요청을 또 다른 객체의 책임으로 변환
- 책임을 담당할 적절한 객체 선택

이 원칙을 조금 생각하면서 실전에서 한번 써먹어보도록 노력해보자.

## 표현적 차이 줄이기

이전 절차적인 설계에서는 알고리즘(행동)의 각 단계를 단일 클래스 안에서 순서대로 배치한 것을 의미한다. 이것을 객체지향적 설계로 변경한다면 알고리즘(행동)의 각 단계를 책임 관점에서 여러 객체로 분배해야 하는데 이것을 **책임 할당**이라고 한다.

책임 설계를 위해서는 앞서 본 것처럼 비즈니스 요구사항(애플리케이션 기능)을 통해 문맥을 얻고 문맥을 통해 객체간 협력을 찾아야 할 것이다. 그러면 이런 협력 객체를 어떻게 선택할까? 바로 여기서 **도메인** 개념이 나오는 것이다. 그리고 이 개념을 통해 **도메인 모델**이라는 것을 추론할 수 있다.

도메인 모델이란, 도메인에 중요한 개념과 관계의 집합으로 객체지향 설계의 재료로 사용되는 도메인을 추상화한 것이라고 보면 된다. 그리고 이 모델은 이런 협력 객체를 찾을 때 가장 먼저 참고되어야 하는 개념과 관계 집합을 뜻한다. 이렇게 참고해야 하는 이유는 바로 **표현적 차이를 줄이기 위해서이다.**

도메인과 실제 코드 상 객체에는 괴리감이 존재할 것이다. 이런 괴리감을 좁히기 위하여 도메인 모델을 사용해야 하고 이 모델을 사용함으로 변경하기 쉬운 유연한 설계를 만들 수 있다는 것이다.

도메인 자체는 비즈니스 도메인 모델이 변경되지 않는 한 크게 변경될 일이 없다. 즉, 안정적이다. 이런 안정적인 모델을 기반으로 코드를 작성하면 해당 코드 구조는 변경에 안정적이 될 수밖에 없다. 즉, 다시 말하면 책임이라는 것을 수행하는데 있어서 적합한 객체를 도메인 모델로 사용한다면 변경에 쉽고 우리 개발자가 이해하기도 쉬울 것이다. 대부분 실무에서도 이렇게 작성되어 있다. 그래서 **도메인 개념**이 중요하다는 것도 여기서 나온 것이다.

객체지향은 명사를 이용해 동사를 묶을 수 있는 개념적인 틀을 제공한다. 요구사항이 변경될 때 도메인 모델을 이용하면 어떤 클래스를 수정해야 할 지 한 눈에 알 수 있을 것이다.

우리가 영화 예매 시스템을 협력 설계를 할 때 기능을 바탕으로 책임을 유추하고 해당 책임으로 **GRASP 패턴**을 적용해 볼 예정이다. GRASP 패턴은 아래와 같이 여러 원칙이 존재한다.

- **creator(창조자)**
- indirection(간접화)
- **information expert(정보 전문가)**
- **polymporphism(다형성)**
- **low coupling(낮은 결합도)**
- **protected variations(변경 보호)**
- **high cohesion(높은 응집도)**
- pure fabrication(순수한 가공물)
- controller(컨트롤러)

해당 패턴을 통해 책임 설계를 진행할 때 우리는 CRC 카드도 이용할 것이다. CRC 카드란, 책임과 협력을 표현하기 위한 객체지향 설계 도구이다.

> 잘못된 지식이 있을 경우 댓글로 남겨주시면 빠르게 반영하겠습니다!