---
title: "[오브젝트] 책임 할당하기"
tags:
  - 자바
image: ./assets/banner.png
date: 2025-06-12 22:32:27
series: 오브젝트
draft: false
---

![배너 이미지](./assets/banner.png)

> 해당 블로그 글은 [조영호님의 인프런 강의](https://inf.run/eUUx4)를 바탕으로 쓰여진 글입니다.

## 정보와 책임 할당 - 정보 전문가

우리가 영화 예매 시스템을 설계하면서 몇가지 지식들을 학습했다. 먼저, 애플리케이션의 기능을 책임으로 할당하고 해당 책임을 각 객체간에 할당을 해야 한다. 그리고 이 과정에서 도메인의 구조를 기반으로 내부의 상태 변경을 가시화해야 한다. 그리고 이렇게 설계를 했으면 사용자에거 어떤 정보를 보여줘야 할지를 결정해야 한다. 즉 영화 예매 시스템의 예매 기능은 사용자에게 예매 정보를 보여줘야 할 것이다. 정리하자면 애플리케이션 기능의 실행은 도메인 개념의 상태나 구조를 변경하는 것이다.

그러면 영화 예매 시스템에서 상영 예매를 시작할 책임은 어떤 객체에게 할당을 하는게 좋을까? 먼저 도메인 구조를 통해 아래와 같이 예매라는 도메인을 추론할 수 있다. 그리고 이 예매 도메인을 사용자에게 전달해야 할 것이다. 그러면 이 예매에 대한 생성의 책임은 어느 객체가 맡는게 좋을까? 여기서 GRASP 패턴 중에 **정보 전문가** 패턴을 도입하면 된다.

정보 전문가 패턴이란, **책임을 객체에게 할당하는 일반적인 원칙**이라는 물음으로 아래와 같은 해결책을 제사한다.

> 책임을 수행하는데 필요한 정보를 가장 많이 알고 있는 객체에게 할당하라.

그런데 뭔가 독자들은 이상하다고 느낄 것이다. 이전 포스팅까지 분명 객체를 설계할 때 데이터를 먼저 설계하는게 아니라 책임(행동)을 먼저 설계하라고 하였다. 그런데 위의 원칙은 정보를 가장 많이 알고 있는 객체에게 할당하라는 것이고 이것은 이미 데이터가 존재한다는 의미일 것이다. 그러면 해당 원칙에 따라 데이터부터 먼저 설계할까? 정답은 **아니요!**이다. 여기서 정보는 데이터가 아니라 행동을 정의하며, 어떤 상태를 수정하거나 질문에 답하는 책임을 뜻한다.

그럼 예시를 하나 들어보자. 만약 어떤 학생이 있고 그 학생의 나이가 궁금하다. 그러면 해당 나이를 물어보는 책임은 어느 객체에게 할당하는게 좋을까? 우리는 바로 알 수 있다. 상식적으로 바로 학생이라고 대답할 것이다. 왜냐하면 해당 학생에 대한 나이의 정보를 가장 많이 알고 있는 것은 자기 자신 학생일 것이기 때문이다. 물론 어느 누군가는 해당 책임을 학생이 아니라 그 학생의 부모님께 책임이 있다고 느낄 수 있을 것이다. 하지만 대다수는 그 학생에게 물어보는게 바람직하다고 느낄 것이다. 이 물음에 대한 정답은 없다. 소속된 팀의 팀원들의 의견을 듣고 대다수가 동의하는 흐름으로 가면 될 것이다. 즉, 이런걸로 인하여 **객체지향은 공통 멘탈의 모델**을 만드는 과정이라고 보면 좋을 것 같다.

그럼 다시 예시로 돌아가서 해당 책임을 학생이라는 객체에게 할당하였으니 아래와 같이 설계를 할 수 있을 것이다. 즉, 아래의 코드처럼 정보는 책임의 관점에서 행동으로 선언한 것이다. 쉽게 생각해서 메서드를 정의했다라고 생각하면 좋다.

``` java
public class Student {
  
  public Integer answerAge() {

  }
}
```

이제 행동을 정의하였으니 내부 구현 코드는 자유롭게 작성이 가능할 것이다. 만약 학생 객체에 내부에 나이라는 데이터를 가지고 있다면 아래와 같이 작성할 수 있을 것이다.

``` java
public class Student {

  private Integer age;
  
  public Integer answerAge() {
    return age;
  }
}
```

만약 나이라는 데이터가 없고 생년월일만 있다면 아래와 같이도 작성할 수 있을 것이다.

``` java
public class Student {

  private LocalDate birthday;
  
  public Integer answerAge() {
    return LocalDate.now().getYear() - birthday.getYear();
  }
}
```

만약 나이라는 데이터가 외부 객체에 있다면 아래와 같이도 작성이 무방할 것이다.

``` java
public class Student {

  private SchoolRecord schoolRecord;
  
  public Integer answerAge() {
    return schoolRecord.search(this).getAge();
  }
}
```

위의 3가지 유형의 코드를 봐서 알겠지만 동일한 정보지만 내부 구현 방식이 전부 다르다. 전문용어로 다시 말하면 메서드 시그니쳐 같은 인터페이스는 동일하지만 구현이 다른 것을 말하는 것이다. 이렇게 책임이 할당되면 내부 구현을 어떻게 하든간에 외부에 영향을 끼칠 일은 전혀 없다. 즉, 이런 이유로 행동을 먼저 결정한 후에 데이터를 결정하라는 이유도 이런 것 때문이다.

그럼 다시 예매 시스템으로 돌아와서 예매를 생성할 책임은 어느 객체가 맡는게 좋을까?

![image1](./assets/01.png)

좋은 방법은 도메인 개념 중에 적절한 정보 전문가에게 할당하는 것이다. 사용자가 받을 예매 데이터는 영화제목, 상영시간, 인원, 금액등이 있을 것이다. 그러면 일단 책임은 영화 도메인과 상영 도메인으로 볼 수 있을 것이다. 그러면 해당 데이터에 영화 도메인이 가장 데이터를 많이 가졌으니 해당 도메인으로 책임을 할당하는게 좋을까? 물론 그럴 수 있지만 위에서 이야기한 것처럼 데이터는 정해져 있지 않고 먼저 행동부터 설계를 하기에 정말 적절한지를 데이터 수와 무관하게 선택을 해야 한다.

여기서 강사님과 나는 예매 정보는 상영시간이 핵심이고 그 외는 부수적이라고 생각했기에 상영 도메인에게 할당할 것이다. 조금 애매하다면 아래와 같이 목적어를 주어로 변경해보자.

> 상영을 예매하다.
> (변경)
> 상영이 예매하다.

위의 예시처럼 목적어를 주어로 변경하였을 때, 어울린다면 그 객체에게 책임을 할당해도 괜찮은 것이다. 그런데 이 외의 더 좋은 방법은 없을까? 이렇게 일일이 실무에서 하기도 애매하지 않을까?

## 설계 트레이드오프 - 창조자와 낮은 결합도

GRASP 패턴 중에 CREATOR(생성자) 패턴을 알아보자. 생성자 패턴은 새로운 인스턴스를 생성하는 책임을 어떤 객체에게 할당할 것인가에 대한 문제를 해결하는 패턴이다. 해결책은 아래와 같다.

- 다음 중 한 가지라도 만족할 경우에 A의 인스턴스 생성 책임을 B에게 할당하라
  - B가 A를 포함하거나 참조한다.
  - B가 A를 기록한다.
  - B가 A를 긴말하게 사용한다.
  - B가 A를 초기화하는 데 필요한 정보를 알고 있다.

그럼 이전에 정보 전문가 패턴으로 선택한 상영 도메인이 정말 적절한건디 생성자 패턴을 통해 알아가 보자. 우리는 예매라는 책임을 통해 예매를 생성하는데 목적이 존재한다. 먼저 애매했던 영화 도메인에게 예매 생성 책임을 져보단고 생각해보자. 위의 생성자 패턴 조건 중에 4번째에 해당이 된다. 영화의 정보는 예약을 생성하는데 필요한 정보들을 영화 도메인은 알고 있다. 그럼 다음 상영 도메인을 알아보자. 상영도메인은 4번째 조건에도 만족하지만 첫번째 조건에도 만족한다. 우리가 도메인 개념을 알아갈 때 설계했던 관계도를 살펴보면 예약과 상영이 밀접한 관련이 있다. 이것을 참조관계라고도 말한다. 이러한 이유로 상영 도메인에게 예약 생성 책임 할당을 하는 것이 적절해보인다.

생성자 패턴을 확인해보았을 때, 1~3번 조건은 뭔가 **결합도**에 관련된 이야기이고 4번은 정보 전문가에 대한 이야기인 듯 보인다. 그럼 결합도에 대해 살펴보자.

결합도란, 객체들이 서로 연관되어 있는 정도를 뜻한다. GRASP 패턴 중에 낮은 결합도 패턴이 존재한다. 낮은 결합도 패턴이란, 어떻게 낮은 의존성을 유지하고, 변경에 따른 영향을 줄이면서 재사용성을 높일까?라는 문제를 가지고 해결책을 제시한다. 해결책은 아래와 같다.

- 설계의 전체적인 결합도를 낮게 유지할 수 있도록 책임을 할당하라

그럼 이 패턴을 영화 예매 시스템에 적용해보자. 만약 영화 객체에 예약을 생성하는 책임을 할당할 경우 영화 객체와 예매 객체간의 관계를 맺어야 한다. 그렇게 되면 영화나 예매 도메인이 변경이 된다면 상영 도메인에도 영향을 끼치게 된다. 그런데 상영 객체에게 책임을 할당하면 이미 상영 객체와 관계가 맺어져 있기에 크게 상관이 없으며 예매 도메인이 변경이 되더라도 영화 도메인까지 영향을 끼치지를 않는다.

## 설계 트레이드오프 - 높은 응집도

결합도와 함께 사용되는 평가기준으로 높은 응집도 패턴이 존재한다. 높은 응집도 패턴이란, 어떻게 낮은 결합도를 유지하고 변경에 따른 영향을 줄이면서 재사용성을 높일까라는 의문에서 아래와 같은 해결책을 제시한다.

- 높은 응집도를 유지하도록 책임을 할당하라.

**높은 응집도**란, 한 요소의 책임이 얼마나 강력하게 관련되고 집중되어 있는가를 판단하고 연관성 높은 책임들을 가지면서 너무 많은 일을 하지 않는 객체에 책임을 할당하는 것이다. 영화 예제 도메인으로 돌아가서 예약을 하기 위하여 예약 생성을 상영 객체에게 할당했다. 그런데 예약을 하려면 먼저 상영정보를 사용자가 선택하고 해당 상영정보의 금액을 계산해야 한다. 그러면 금액 계산이라는 책임은 어느 객체에게 할당할까? 정보 전문가 패턴을 통해 보면 가격 계산은 가격이 매인 핵심이므로 영화 객체에게 할당하는게 좋다. 또한 낮은 결합도 측면에서 가격을 계산하려면 각종 할인 정책들을 통해 계산을 하는데 영화 객체는 이미 할인 정책과 할인 도메인과 참조가 이루어져 있다.

그래서 예약 생성을 만약 영화 객체에게 할당했다면 예약 생성이라는 책임과 가격 계산이라는 책임, 서로 관련 없는 책임들이 혼재하기에 높은 응집도가 아닌 낮은 응집도로 어긋난다. 낮은 응집도가 되버리면 연관성 없는 코드들이 혼재하여 우리가 코드를 읽는데 불편함을 주고 한 가지 책임을 수정할 경우 이로 인해 상관 없는 나머지 책임이 영향을 받을 수 있기 때문이다.

## 유연한 설계 - 다형성

현재 우리는 영화 가격 정보를 알고 있는 영화 객체에게 책임을 할당시켰다. 그러면 다음으로 할인 금액을 계산하는 정보 전문가는 누굴까? 바로 할인 정책 객체이다. 왜냐하면 할인 정책 객체는 금액으로 할인하는데 필요한 정보를 알고 있기 때문이다.

그러면 지금 만약 영화가 비율 할인을 적용해서 계산을 해야한다면 비율 할인으로 계산하라는 **메세지**를 할인 정책 객체에게 전달해야 하고 만약 금액 할인으로 계산하라는 **메세지**를 할인 정책 객체에게 전달해야 한다. 그러면 여러분은 이제 눈치를 챘을 것이다. 바로 bad practice이다. 왜냐하면 지금 영화 객체와 할인 정책 객체간의 높은 결합도가 유지되기 때문이다. 이런 케이스를 코드로 보면 아마 아래와 유사할 것이다.

``` java
public class Movie {
  private DiscountPolicy discountPolicy;

  public Money calculateFee(...) {
    if (금액 할인 조건이면) {
      return discountPolicy.calculateAmountDiscount();
    }

    return discountPolicy.calculatePercentDiscount();
  }
}
```

``` java
public class DiscountPolicy {

  public Money calculateAmountDiscount() {
    //
  }

  public Money calculatePercentDiscount() {
    //
  }
}
```

이렇게 코드로 보니 한 가지 더 문제가 있다. 바로 낮은 응집도 문제이다. 지금 `DiscountPolicy` 클래스에는 뭔가 로직이 비슷해보이지만 공통적인 부분이 없는 메서드가 2개 존재한다. 그리고 만약 아래와 같이 새로운 할인 정책이 추가된다면 어떻게 될까?

``` java
public class DiscountPolicy {

  public Money calculateAmountDiscount() {
    //
  }

  public Money calculatePercentDiscount() {
    //
  }

  public Money calculateOverlappedDiscount() {
    //
  }
}
```

그러면 변경의 여파는 바로 `Movie` 객체까지 가게 된다. 기존의 조건문에 하나 더 추가해서 분기를 나눠줘야 한다. 바로 아래와 같이 말이다.

``` java
public class Movie {
  private DiscountPolicy discountPolicy;

  public Money calculateFee(...) {
    if (금액 할인 조건이면) {
      return discountPolicy.calculateAmountDiscount();
    }

    if (비율 할인 조건이라면) {
      return discountPolicy.calculatePercentDiscount();
    }

    return discountPolicy.calculateOverlappedDiscount();
  }
}
```

이렇게 되면 외부에서 사용하는 `calculateFee`도 변경이 되었고 그 변경 여파가 외부까지 전파되게 된다. 이런 문제를 해결하기 위해 GRASP 패턴에서 다형성 패턴을 제공한다. 다형성 패턴은 타입을 기반으로 유사하지만 서로 다르게 행동할때 문제를 해결하고자 했다. 즉, 위의 코드에서 조건문을 사용하지 않고 금액 계산을 어떻게 할까? 바로 **다형적 메세지를 이용해서 행동이 변하는 타입들에게 각 행동을 다루기 위한 책임을 할당하라**로 해결책을 제시한다. 여기서 눈여겨 볼 부분은 바로 **행동이 변하는 타입들에게 각 행동을 다루기 위한 책임을 할당**이다.

영화의 입장에서는 할인 정책의 행동은 시간에 따라 뭔가 변하는 존재로 인식한다. 그리고 서로 다른 방식으로 동작하는 두가지 종류의 타입인 금액 할인 정책 타입과 비율 할인 정책 타입을 할인 정책이라는 하나의 후부로 할당했기에 더욱이나 영화 객체는 할인 정책이 변경되는 존재처럼 느낄 것이다. 서로 다른 책임이 하나의 후보 안에 뭉쳐 있다면 일단은 서로 다른 책임을 서로 다른 타입의 객체에 할당하는 것이다. 즉 아래와 같이 말이다.

``` java
public class AmountDiscountPolicy {

  public Money calculateAmountDiscount() {
    //
  }
}
```

``` java
public class PercentDiscountPolicy {

  public Money calculatePercentDiscount() {
    //
  }
}
```

그리고 이 정책 타입들을 영화 객체가 알고 있으면 되는 것이다. 아래 처럼 말이다.

``` java
public class Movie {
  private AmountDiscountPolicy amountDiscountPolicy;
  private PercentDiscountPolicy percentDiscountPolicy;

  public Money calculateFee(...) {
    if (금액 할인 조건이면) {
      return amountDiscountPolicy.calculateAmountDiscount();
    }

    if (비율 할인 조건이라면) {
      return percentDiscountPolicy.calculatePercentDiscount();
    }

    return discountPolicy.calculateOverlappedDiscount();
  }
}
```

하지만 여전히 높은 결합도는 존재한다. 일단 조건문이 사라지지 못했고 만약 새로운 정책이 생기면 클래스를 생성하고 이 정책을 `Movie` 객체가 알아야 하기 때문이다. 또한 조건문은 똑같이 증가한다.

## 결합도 낮추기 - 변경 보호

그럼 위의 문제를 어떻게 해결할까? 바로 다형성 패턴의 해결책으로 제시된 것 중에 **다형적 메세지**를 이용하는 방식이다.

> 📚 용어 정리
>
> 메세지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이며, 객체는 다른 객체에게 협력을 요청하기 위해 메세지를 전송한다.

영화는 메세지를 이용해서 할인 정책 객체에게 협력을 요청한다. 할인 정책은 정책 별로 책임을 수행하는 방법은 다르지만 영화 입장에서는 어처피 받아야 할 것이 금액이기에 똑같은 놈들로 보이기 마련이다. 즉, 협력이라는 문맥 안에서 금액 할인 정책과 비율 할인 정책은 같은 객체이다. 그러면 다형적 메세지로 변경을 하면 어떻게 될까? 바로 자바의 인터페이스를 통한 추상화 단계를 거치는 것이다. 즉, 영화 객체는 추상화된 인터페이스한테 다형적 메세지를 보내고 해당 인터페이스가 알아서 금액 할인 정책을 하든 비율 할인 정책을 하든 계산하여 반환해주는 역할을 할 것이다.

> 📚 용어 정리
>
> 다형적 메세지란, 동일한 요청, 타입에 따른 행동을 한 후에 동일한 결과가 나온다는 의미이다.

즉 위의 인터페이스를 두고 영화가 구체화된 정책 객체를 참조하는 대신에 추상화된 정책 객체만 바라보게 하는 것을 바로 GRASP 패턴 중 변경 보호 패턴이라고 한다. 변경 보호 패턴은 요소들의 변화나 불안정한 요소가 다른 요소에 해로운 영향을 미치지 않게끔 변화가 예상되거나 불안정한 지점을 식별하고 그 주위에 안정적인 인터페이스 또는 추상화를 형성하도록 책임을 할당하는 패턴이다. 즉, 다형성을 이루는 것이다.

> 📚 용어 정리
>
> 다형성이란, 메세지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행하는 행동이 달라지는 능력을 의미한다.

위의 패턴을 적용하여 다형성을 이루면서 책임과 역할, 협력이 구분되게 된다. 한 종류의 객체만 요청에 응답하면 객체와 역할이 동일하다고 하며, 그게 아니라 추상화를 통해 다형성을 구현하면 객체와 역할이 다르다고 판단하는 것이다.

정리를 하자면 하나의 책임을 가지고 행동을 구현하려고 객체 간 협력이 필요하게 되고 그러다 보니 역할의 개념도 나오게 된 것 같다.

이렇게 할인 정책을 다형성 원리를 이용하여 구현하였다면 이제 언제 어떤 할인 정책을 써야 할지 판단하는 책임을 할인 조건에 물어야 할 것이다. 만약 이 책임을 할인 정책에 묻는다면 낮은 응집도를 보이기 때문일 것이다. 아마 할인 조건도 이와 유사하게 다형성 원리를 이용한다면 쉽게 구현이 가능할 것이다.

> 잘못된 지식이 있을 경우 댓글로 남겨주시면 빠르게 반영하겠습니다!